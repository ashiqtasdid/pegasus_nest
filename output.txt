Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender
==================================================
File: compiled_files.txt
--------------------------------------------------
Folder: D:\Codespace\pegasus_api\generated\autoclaimdefender
==================================================

File: pom.xml
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.pegasus</groupId>
    <artifactId>MyBasicPlugin</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>MyBasicPlugin</name>
    <description>A basic Minecraft plugin example with pegasus package.</description>

    <properties>
        <java.version>17</java.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <repositories>
        <repository>
            <id>papermc-repo</id>
            <url>https://repo.papermc.io/repository/maven-public/</url>
        </repository>
        <repository>
            <id>sonatype</id>
            <url>https://oss.sonatype.org/content/groups/public/</url>
        </repository>
    </repositories>

    <dependencies>
        <dependency>
            <groupId>io.papermc.paper</groupId>
            <artifactId>paper-api</artifactId>
            <version>1.20.4-R0.1-SNAPSHOT</version> <!-- This API version works well with Java 17 -->
            <scope>provided</scope>
        </dependency>
    </dependencies>

    <build>
        <defaultGoal>clean package</defaultGoal>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version> <!-- This version of compiler plugin is fine -->
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.2.4</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <createDependencyReducedPom>false</createDependencyReducedPom>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>
</project>

    
--------------------------------------------------

Folder: D:\Codespace\pegasus_api\generated\autoclaimdefender\src
==================================================

Folder: D:\Codespace\pegasus_api\generated\autoclaimdefender\src\main
==================================================

Folder: D:\Codespace\pegasus_api\generated\autoclaimdefender\src\main\java
==================================================

Folder: D:\Codespace\pegasus_api\generated\autoclaimdefender\src\main\java\com
==================================================

Folder: D:\Codespace\pegasus_api\generated\autoclaimdefender\src\main\java\com\pegasus
==================================================

Folder: D:\Codespace\pegasus_api\generated\autoclaimdefender\src\main\java\com\pegasus\mybasicplugin
==================================================

Folder: D:\Codespace\pegasus_api\generated\autoclaimdefender\src\main\java\com\pegasus\mybasicplugin\listeners
==================================================

File: PlayerJoinListener.java
--------------------------------------------------
package com.pegasus.mybasicplugin.listeners;

import com.pegasus.mybasicplugin.MyBasicPlugin; 
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;

public class PlayerJoinListener implements Listener {

    private final MyBasicPlugin plugin;

    public PlayerJoinListener(MyBasicPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onPlayerJoin(PlayerJoinEvent event) {
        Player player = event.getPlayer();

        if (plugin.getConfig().getBoolean("enable-welcome-message", true)) {
            String welcomeMessageFormat = plugin.getConfig().getString("welcome-message", "Welcome to the server, %player%!");
            String personalizedMessage = welcomeMessageFormat.replace("%player%", player.getName());

            player.sendMessage(ChatColor.translateAlternateColorCodes('&', personalizedMessage));
            plugin.getLogger().info(player.getName() + " joined. Sent welcome message.");
        } else {
            plugin.getLogger().info(player.getName() + " joined. Welcome message is disabled.");
        }
    }
}
--------------------------------------------------

File: MyBasicPlugin.java
--------------------------------------------------
package com.pegasus.mybasicplugin;

import com.pegasus.mybasicplugin.listeners.PlayerJoinListener; 
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.ChatColor;

public class MyBasicPlugin extends JavaPlugin {

    private static MyBasicPlugin instance;

    @Override
    public void onEnable() {
        instance = this;

        saveDefaultConfig();

        String welcomeMessage = getConfig().getString("welcome-message", "Welcome, %player%!");
        boolean enableWelcome = getConfig().getBoolean("enable-welcome-message", true);

        getServer().getPluginManager().registerEvents(new PlayerJoinListener(this), this);

        getLogger().info(ChatColor.GREEN + getName() + " version " + getDescription().getVersion() + " has been enabled!");
        getLogger().info("Welcome message enabled: " + enableWelcome + ", Message: " + welcomeMessage);
    }

    @Override
    public void onDisable() {
        getLogger().info(ChatColor.RED + getName() + " has been disabled!");
        instance = null;
    }

    public static MyBasicPlugin getInstance() {
        return instance;
    }
}
--------------------------------------------------

Folder: D:\Codespace\pegasus_api\generated\autoclaimdefender\src\resources
==================================================

File: config.yml
--------------------------------------------------
# MyBasicPlugin Configuration

# Message to send to players when they join
welcome-message: "Welcome to the server, %player%!"
enable-welcome-message: true

# An example setting
some-feature-enabled: false
some-value: 10
--------------------------------------------------

File: plugin.yml
--------------------------------------------------
name: ${project.name}
version: ${project.version}
main: com.pegasus.mybasicplugin.MyBasicPlugin # Change this to your main class
api-version: '1.17'

author: YourName
description: ${project.description}
website: yourwebsite.com
--------------------------------------------------


--------------------------------------------------

File: compiled_output.txt
--------------------------------------------------

--------------------------------------------------

File: gemini_response.txt
--------------------------------------------------
```json
{
  "createdFiles": [
    {
      "path": "src/main/java/com/autoclaimdefender/Claim.java",
      "content": "package com.autoclaimdefender;\n\nimport org.bukkit.Chunk;\nimport org.bukkit.Location;\nimport org.bukkit.World;\nimport org.bukkit.configuration.serialization.ConfigurationSerializable;\nimport org.bukkit.entity.Player;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Claim implements ConfigurationSerializable {\n    private UUID ownerUUID;\n    private String ownerName; // For easier identification, not for primary key\n    private String worldName;\n    private Set<Long> chunkKeys; // Packed chunk coords (x << 32 | z)\n    private Set<UUID> trustedPlayers;\n    private Date creationDate;\n\n    public Claim(UUID ownerUUID, String ownerName, World world, Set<Chunk> chunks) {\n        this.ownerUUID = ownerUUID;\n        this.ownerName = ownerName;\n        this.worldName = world.getName();\n        this.chunkKeys = new HashSet<>();\n        for (Chunk chunk : chunks) {\n            this.chunkKeys.add(packChunkCoords(chunk.getX(), chunk.getZ()));\n        }\n        this.trustedPlayers = new HashSet<>();\n        this.creationDate = new Date();\n    }\n\n    // Deserialization constructor\n    @SuppressWarnings(\"unchecked\")\n    public Claim(Map<String, Object> map) {\n        this.ownerUUID = UUID.fromString((String) map.get(\"ownerUUID\"));\n        this.ownerName = (String) map.get(\"ownerName\");\n        this.worldName = (String) map.get(\"worldName\");\n        this.chunkKeys = ((List<Long>) map.get(\"chunkKeys\")).stream().collect(Collectors.toSet());\n        this.trustedPlayers = ((List<String>) map.get(\"trustedPlayers\")).stream()\n                .map(UUID::fromString)\n                .collect(Collectors.toSet());\n        this.creationDate = (Date) map.get(\"creationDate\");\n    }\n\n    @Override\n    public Map<String, Object> serialize() {\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"ownerUUID\", ownerUUID.toString());\n        map.put(\"ownerName\", ownerName);\n        map.put(\"worldName\", worldName);\n        map.put(\"chunkKeys\", new ArrayList<>(chunkKeys));\n        map.put(\"trustedPlayers\", trustedPlayers.stream().map(UUID::toString).collect(Collectors.toList()));\n        map.put(\"creationDate\", creationDate);\n        return map;\n    }\n\n    public static long packChunkCoords(int x, int z) {\n        return (long) x << 32 | (long) z & 0xFFFFFFFFL;\n    }\n\n    public static int unpackChunkX(long key) {\n        return (int) (key >> 32);\n    }\n\n    public static int unpackChunkZ(long key) {\n        return (int) (key & 0xFFFFFFFFL);\n    }\n\n    public UUID getOwnerUUID() {\n        return ownerUUID;\n    }\n\n    public String getOwnerName() {\n        return ownerName;\n    }\n\n    public String getWorldName() {\n        return worldName;\n    }\n\n    public Set<Long> getChunkKeys() {\n        return Collections.unmodifiableSet(chunkKeys);\n    }\n\n    public boolean isChunkInClaim(Chunk chunk) {\n        return chunk.getWorld().getName().equals(worldName) && chunkKeys.contains(packChunkCoords(chunk.getX(), chunk.getZ()));\n    }\n\n    public boolean isLocationInClaim(Location location) {\n        return isChunkInClaim(location.getChunk());\n    }\n\n    public boolean isTrusted(Player player) {\n        return isTrusted(player.getUniqueId());\n    }\n\n    public boolean isTrusted(UUID playerUUID) {\n        return trustedPlayers.contains(playerUUID) || playerUUID.equals(ownerUUID);\n    }\n\n    public void trustPlayer(UUID playerUUID) {\n        trustedPlayers.add(playerUUID);\n    }\n\n    public void untrustPlayer(UUID playerUUID) {\n        trustedPlayers.remove(playerUUID);\n    }\n\n    public Set<UUID> getTrustedPlayers() {\n        return Collections.unmodifiableSet(trustedPlayers);\n    }\n    \n    public Date getCreationDate() {\n        return creationDate;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Claim claim = (Claim) o;\n        return ownerUUID.equals(claim.ownerUUID) && worldName.equals(claim.worldName) && chunkKeys.equals(claim.chunkKeys);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(ownerUUID, worldName, chunkKeys);\n    }\n}\n"
    },
    {
      "path": "src/main/java/com/autoclaimdefender/ClaimManager.java",
      "content": "package com.autoclaimdefender;\n\nimport org.bukkit.Chunk;\nimport org.bukkit.Location;\nimport org.bukkit.OfflinePlayer;\nimport org.bukkit.World;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.entity.Player;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Collectors;\n\npublic class ClaimManager {\n    private final AutoClaimDefender plugin;\n    private final Map<UUID, List<Claim>> playerClaims = new ConcurrentHashMap<>(); // Owner UUID to their claims\n    private final Set<UUID> autoClaimedPlayers = ConcurrentHashMap.newKeySet(); // Players who have used their first auto-claim\n    private File dataFile;\n\n    public ClaimManager(AutoClaimDefender plugin) {\n        this.plugin = plugin;\n        this.dataFile = new File(plugin.getDataFolder(), \"claims_data.yml\");\n        loadClaims();\n    }\n\n    public Claim createClaim(Player owner, Set<Chunk> chunksToClaim) {\n        if (chunksToClaim.isEmpty()) {\n            return null;\n        }\n        // Check for overlaps with existing claims\n        for (Chunk chunk : chunksToClaim) {\n            if (getClaimAt(chunk) != null) {\n                owner.sendMessage(plugin.getMessage(\"claim.error.overlap\"));\n                return null;\n            }\n        }\n\n        Claim claim = new Claim(owner.getUniqueId(), owner.getName(), chunksToClaim.iterator().next().getWorld(), chunksToClaim);\n        playerClaims.computeIfAbsent(owner.getUniqueId(), k -> new ArrayList<>()).add(claim);\n        saveClaims();\n        return claim;\n    }\n\n    public boolean abandonClaim(Claim claim) {\n        if (claim == null) return false;\n        List<Claim> claims = playerClaims.get(claim.getOwnerUUID());\n        if (claims != null) {\n            boolean removed = claims.remove(claim);\n            if (claims.isEmpty()) {\n                playerClaims.remove(claim.getOwnerUUID());\n            }\n            if (removed) {\n                saveClaims();\n            }\n            return removed;\n        }\n        return false;\n    }\n    \n    public boolean abandonAllClaims(UUID ownerUUID) {\n        if (playerClaims.containsKey(ownerUUID)) {\n            playerClaims.remove(ownerUUID);\n            saveClaims();\n            return true;\n        }\n        return false;\n    }\n\n    public Claim getClaimAt(Location location) {\n        return getClaimAt(location.getChunk());\n    }\n\n    public Claim getClaimAt(Chunk chunk) {\n        long chunkKey = Claim.packChunkCoords(chunk.getX(), chunk.getZ());\n        String worldName = chunk.getWorld().getName();\n        for (List<Claim> claims : playerClaims.values()) {\n            for (Claim claim : claims) {\n                if (claim.getWorldName().equals(worldName) && claim.getChunkKeys().contains(chunkKey)) {\n                    return claim;\n                }\n            }\n        }\n        return null;\n    }\n\n    public List<Claim> getPlayerClaims(UUID playerUUID) {\n        return playerClaims.getOrDefault(playerUUID, Collections.emptyList());\n    }\n\n    public int getPlayerClaimCount(UUID playerUUID) {\n        return getPlayerClaims(playerUUID).size();\n    }\n\n    public void markPlayerAsAutoClaimed(Player player) {\n        autoClaimedPlayers.add(player.getUniqueId());\n        saveClaims(); // Save this status as well\n    }\n\n    public boolean hasPlayerAutoClaimed(Player player) {\n        return autoClaimedPlayers.contains(player.getUniqueId());\n    }\n\n    public void trustPlayerInClaim(Claim claim, OfflinePlayer trustedPlayer) {\n        claim.trustPlayer(trustedPlayer.getUniqueId());\n        saveClaims();\n    }\n\n    public void untrustPlayerInClaim(Claim claim, OfflinePlayer untrustedPlayer) {\n        claim.untrustPlayer(untrustedPlayer.getUniqueId());\n        saveClaims();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void loadClaims() {\n        if (!dataFile.exists()) {\n            return;\n        }\n        FileConfiguration dataConfig = YamlConfiguration.loadConfiguration(dataFile);\n        List<Map<?, ?>> claimsList = dataConfig.getMapList(\"claims\");\n        for (Map<?, ?> claimMap : claimsList) {\n            Claim claim = new Claim((Map<String, Object>) claimMap);\n            playerClaims.computeIfAbsent(claim.getOwnerUUID(), k -> new ArrayList<>()).add(claim);\n        }\n\n        List<String> autoClaimedUUIDs = dataConfig.getStringList(\"autoClaimedPlayers\");\n        for (String uuidStr : autoClaimedUUIDs) {\n            try {\n                autoClaimedPlayers.add(UUID.fromString(uuidStr));\n            } catch (IllegalArgumentException e) {\n                plugin.getLogger().warning(\"Failed to load auto-claimed player UUID: \" + uuidStr);\n            }\n        }\n    }\n\n    public void saveClaims() {\n        FileConfiguration dataConfig = new YamlConfiguration();\n        List<Map<String, Object>> claimsToSave = new ArrayList<>();\n        for (List<Claim> claims : playerClaims.values()) {\n            for (Claim claim : claims) {\n                claimsToSave.add(claim.serialize());\n            }\n        }\n        dataConfig.set(\"claims\", claimsToSave);\n        dataConfig.set(\"autoClaimedPlayers\", autoClaimedPlayers.stream().map(UUID::toString).collect(Collectors.toList()));\n\n        try {\n            dataConfig.save(dataFile);\n        } catch (IOException e) {\n            plugin.getLogger().severe(\"Could not save claims data to \" + dataFile.getName());\n            e.printStackTrace();\n        }\n    }\n}\n"
    },
    {
      "path": "src/main/java/com/autoclaimdefender/commands/CoreCommand.java",
      "content": "package com.autoclaimdefender.commands;\n\nimport com.autoclaimdefender.AutoClaimDefender;\nimport com.autoclaimdefender.Claim;\nimport com.autoclaimdefender.ClaimManager;\nimport org.bukkit.*;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.bukkit.entity.Player;\nimport org.bukkit.scheduler.BukkitRunnable;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class CoreCommand implements CommandExecutor, TabCompleter {\n    private final AutoClaimDefender plugin;\n    private final ClaimManager claimManager;\n\n    public CoreCommand(AutoClaimDefender plugin) {\n        this.plugin = plugin;\n        this.claimManager = plugin.getClaimManager();\n    }\n\n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if (args.length == 0 || args[0].equalsIgnoreCase(\"help\")) {\n            sendHelpMessage(sender, label);\n            return true;\n        }\n\n        String subCommand = args[0].toLowerCase();\n\n        if (!(sender instanceof Player) && needsPlayer(subCommand)) {\n            sender.sendMessage(plugin.getMessage(\"command.error.player-only\"));\n            return true;\n        }\n\n        Player player = (sender instanceof Player) ? (Player) sender : null;\n\n        switch (subCommand) {\n            case \"claim\":\n                return handleClaim(player, args);\n            case \"abandon\":\n            case \"abandonclaim\":\n                return handleAbandonClaim(player, args);\n            case \"trust\":\n                return handleTrust(player, args);\n            case \"untrust\":\n                return handleUntrust(player, args);\n            case \"list\":\n            case \"claims\":\n                return handleListClaims(player, args);\n            case \"border\":\n            case \"showborder\":\n                return handleShowBorder(player);\n            case \"admin\":\n                 if (!sender.hasPermission(\"autoclaimdefender.admin\")) {\n                    sender.sendMessage(plugin.getMessage(\"command.error.no-permission\"));\n                    return true;\n                }\n                return handleAdminCommands(sender, args, label);\n            default:\n                sendHelpMessage(sender, label);\n                return true;\n        }\n    }\n\n    private boolean needsPlayer(String subCommand) {\n        return Arrays.asList(\"claim\", \"abandon\", \"abandonclaim\", \"trust\", \"untrust\", \"list\", \"claims\", \"border\", \"showborder\").contains(subCommand);\n    }\n\n    private void sendHelpMessage(CommandSender sender, String label) {\n        sender.sendMessage(ChatColor.GOLD + \"--- AutoClaim Defender Help ---\");\n        sender.sendMessage(ChatColor.YELLOW + \"/\" + label + \" claim\" + ChatColor.GRAY + \" - Claims the chunk you are standing in.\");\n        sender.sendMessage(ChatColor.YELLOW + \"/\" + label + \" abandon\" + ChatColor.GRAY + \" - Abandons the claim you are in.\");\n        sender.sendMessage(ChatColor.YELLOW + \"/\" + label + \" trust <player>\" + ChatColor.GRAY + \" - Trusts a player in your claim.\");\n        sender.sendMessage(ChatColor.YELLOW + \"/\" + label + \" untrust <player>\" + ChatColor.GRAY + \" - Untrusts a player from your claim.\");\n        sender.sendMessage(ChatColor.YELLOW + \"/\" + label + \" list\" + ChatColor.GRAY + \" - Lists your claims.\");\n        sender.sendMessage(ChatColor.YELLOW + \"/\" + label + \" showborder\" + ChatColor.GRAY + \" - Shows the border of the current claim.\");\n        if (sender.hasPermission(\"autoclaimdefender.admin\")) {\n            sender.sendMessage(ChatColor.RED + \"/\" + label + \" admin <subcommand>\" + ChatColor.GRAY + \" - Admin commands.\");\n        }\n    }\n\n    private boolean handleClaim(Player player, String[] args) {\n        if (!player.hasPermission(\"autoclaimdefender.claim\")) {\n            player.sendMessage(plugin.getMessage(\"command.error.no-permission\"));\n            return true;\n        }\n\n        int maxClaims = plugin.getConfig().getInt(\"claims.max-claims-per-player\", 5);\n        if (claimManager.getPlayerClaimCount(player.getUniqueId()) >= maxClaims && !player.hasPermission(\"autoclaimdefender.bypass.claimlimit\")) {\n            player.sendMessage(plugin.getMessage(\"claim.error.max-claims-reached\").replace(\"{max_claims}\", String.valueOf(maxClaims)));\n            return true;\n        }\n\n        // Economy check (placeholder)\n        if (plugin.getConfig().getBoolean(\"economy.enabled\") && claimManager.getPlayerClaimCount(player.getUniqueId()) >= plugin.getConfig().getInt(\"economy.free-claims\")) {\n            double cost = plugin.getConfig().getDouble(\"economy.cost-per-additional-claim\");\n            // TODO: Implement Vault economy check and charge. For now, just a message.\n            player.sendMessage(ChatColor.YELLOW + \"Claiming this chunk would cost \" + cost + \" (Economy not fully implemented yet).\");\n        }\n\n        Set<Chunk> chunksToClaim = new HashSet<>();\n        chunksToClaim.add(player.getLocation().getChunk());\n        // Potentially expand to a configurable radius if args specify, e.g. /claim 3x3\n\n        Claim claim = claimManager.createClaim(player, chunksToClaim);\n        if (claim != null) {\n            player.sendMessage(plugin.getMessage(\"claim.success.manual\"));\n        } else {\n            // Error message already sent by ClaimManager (e.g., overlap)\n        }\n        return true;\n    }\n\n    private boolean handleAbandonClaim(Player player, String[] args) {\n        if (!player.hasPermission(\"autoclaimdefender.abandon\")) {\n            player.sendMessage(plugin.getMessage(\"command.error.no-permission\"));\n            return true;\n        }\n\n        Claim claim = claimManager.getClaimAt(player.getLocation());\n        if (claim == null || !claim.getOwnerUUID().equals(player.getUniqueId())) {\n            player.sendMessage(plugin.getMessage(\"claim.error.not-in-own-claim\"));\n            return true;\n        }\n\n        if (claimManager.abandonClaim(claim)) {\n            player.sendMessage(plugin.getMessage(\"claim.success.abandoned\"));\n        } else {\n            player.sendMessage(plugin.getMessage(\"claim.error.abandon-failed\"));\n        }\n        return true;\n    }\n\n    private boolean handleTrust(Player player, String[] args) {\n        if (!player.hasPermission(\"autoclaimdefender.trust\")) {\n            player.sendMessage(plugin.getMessage(\"command.error.no-permission\"));\n            return true;\n        }\n        if (args.length < 2) {\n            player.sendMessage(plugin.getMessage(\"command.usage.trust\"));\n            return true;\n        }\n\n        Claim claim = claimManager.getClaimAt(player.getLocation());\n        if (claim == null || !claim.getOwnerUUID().equals(player.getUniqueId())) {\n            player.sendMessage(plugin.getMessage(\"claim.error.not-in-own-claim\"));\n            return true;\n        }\n\n        OfflinePlayer target = Bukkit.getOfflinePlayer(args[1]);\n        if (!target.hasPlayedBefore() && !target.isOnline()) {\n            player.sendMessage(plugin.getMessage(\"command.error.player-not-found\").replace(\"{player_name}\", args[1]));\n            return true;\n        }\n        if (target.getUniqueId().equals(player.getUniqueId())){\n            player.sendMessage(plugin.getMessage(\"trust.error.self\"));\n            return true;\n        }\n\n        claimManager.trustPlayerInClaim(claim, target);\n        player.sendMessage(plugin.getMessage(\"trust.success\").replace(\"{player_name}\", target.getName()));\n        return true;\n    }\n\n    private boolean handleUntrust(Player player, String[] args) {\n        if (!player.hasPermission(\"autoclaimdefender.untrust\")) {\n            player.sendMessage(plugin.getMessage(\"command.error.no-permission\"));\n            return true;\n        }\n        if (args.length < 2) {\n            player.sendMessage(plugin.getMessage(\"command.usage.untrust\"));\n            return true;\n        }\n\n        Claim claim = claimManager.getClaimAt(player.getLocation());\n        if (claim == null || !claim.getOwnerUUID().equals(player.getUniqueId())) {\n            player.sendMessage(plugin.getMessage(\"claim.error.not-in-own-claim\"));\n            return true;\n        }\n\n        OfflinePlayer target = Bukkit.getOfflinePlayer(args[1]);\n         if (!target.hasPlayedBefore() && !target.isOnline()) { // Check if player is known\n            // Try to find by UUID if name changed, or check from claim's trusted list\n            UUID targetUUID = null;\n            for(UUID trustedId : claim.getTrustedPlayers()){\n                OfflinePlayer p = Bukkit.getOfflinePlayer(trustedId);\n                if(p.getName() != null && p.getName().equalsIgnoreCase(args[1])){\n                    targetUUID = trustedId;\n                    target = p;\n                    break;\n                }\n            }\n            if(targetUUID == null){\n                player.sendMessage(plugin.getMessage(\"command.error.player-not-found-or-not-trusted\").replace(\"{player_name}\", args[1]));\n                return true;\n            }\n        }\n\n        if (!claim.getTrustedPlayers().contains(target.getUniqueId())){\n            player.sendMessage(plugin.getMessage(\"untrust.error.not-trusted\").replace(\"{player_name}\", target.getName()));\n            return true;\n        }\n\n        claimManager.untrustPlayerInClaim(claim, target);\n        player.sendMessage(plugin.getMessage(\"untrust.success\").replace(\"{player_name}\", target.getName()));\n        return true;\n    }\n\n    private boolean handleListClaims(Player player, String[] args) {\n        if (!player.hasPermission(\"autoclaimdefender.list\")) {\n            player.sendMessage(plugin.getMessage(\"command.error.no-permission\"));\n            return true;\n        }\n\n        List<Claim> claims = claimManager.getPlayerClaims(player.getUniqueId());\n        if (claims.isEmpty()) {\n            player.sendMessage(plugin.getMessage(\"claim.list.none\"));\n            return true;\n        }\n\n        player.sendMessage(plugin.getMessage(\"claim.list.header\").replace(\"{count}\", String.valueOf(claims.size())));\n        for (int i = 0; i < claims.size(); i++) {\n            Claim claim = claims.get(i);\n            long firstChunkKey = claim.getChunkKeys().iterator().next();\n            int chunkX = Claim.unpackChunkX(firstChunkKey);\n            int chunkZ = Claim.unpackChunkZ(firstChunkKey);\n            player.sendMessage(ChatColor.YELLOW + \" \" + (i + 1) + \". \" + ChatColor.GRAY + \"World: \" + claim.getWorldName() + \", Chunks: \" + claim.getChunkKeys().size() + \" (e.g., at X: \" + chunkX + \", Z: \" + chunkZ + \")\");\n        }\n        return true;\n    }\n\n    private boolean handleShowBorder(Player player) {\n        if (!plugin.getConfig().getBoolean(\"visual-borders.enabled\")) {\n            player.sendMessage(plugin.getMessage(\"borders.disabled\"));\n            return true;\n        }\n        if (!player.hasPermission(\"autoclaimdefender.showborder\")) {\n            player.sendMessage(plugin.getMessage(\"command.error.no-permission\"));\n            return true;\n        }\n\n        Claim claim = claimManager.getClaimAt(player.getLocation());\n        if (claim == null) {\n            player.sendMessage(plugin.getMessage(\"claim.error.not-in-claim\"));\n            return true;\n        }\n\n        player.sendMessage(plugin.getMessage(\"borders.showing\"));\n        showClaimBorders(player, claim);\n        return true;\n    }\n\n    private void showClaimBorders(Player player, Claim claim) {\n        World world = Bukkit.getWorld(claim.getWorldName());\n        if (world == null) return;\n\n        Particle particleType;\n        try {\n            particleType = Particle.valueOf(plugin.getConfig().getString(\"visual-borders.particle-type\", \"REDSTONE\").toUpperCase());\n        } catch (IllegalArgumentException e) {\n            particleType = Particle.REDSTONE;\n            plugin.getLogger().warning(\"Invalid particle type in config.yml, defaulting to REDSTONE.\");\n        }\n        final Particle finalParticleType = particleType;\n        \n        new BukkitRunnable() {\n            @Override\n            public void run() {\n                for (long chunkKey : claim.getChunkKeys()) {\n                    int chunkX = Claim.unpackChunkX(chunkKey);\n                    int chunkZ = Claim.unpackChunkZ(chunkKey);\n                    Chunk chunk = world.getChunkAt(chunkX, chunkZ);\n\n                    for (int i = 0; i < 16; i++) {\n                        // Top and bottom edges (X direction)\n                        world.spawnParticle(finalParticleType, chunk.getBlock(i, player.getLocation().getBlockY(), 0).getLocation().add(0.5, 0.5, 0.5), 1, 0, 0, 0, 0);\n                        world.spawnParticle(finalParticleType, chunk.getBlock(i, player.getLocation().getBlockY(), 15).getLocation().add(0.5, 0.5, 0.5), 1, 0, 0, 0, 0);\n                        // Left and right edges (Z direction)\n                        world.spawnParticle(finalParticleType, chunk.getBlock(0, player.getLocation().getBlockY(), i).getLocation().add(0.5, 0.5, 0.5), 1, 0, 0, 0, 0);\n                        world.spawnParticle(finalParticleType, chunk.getBlock(15, player.getLocation().getBlockY(), i).getLocation().add(0.5, 0.5, 0.5), 1, 0, 0, 0, 0);\n                    }\n                }\n            }\n        }.runTaskLater(plugin, 0L); // Show immediately\n        \n        // Could add a task to remove them or show for a limited time\n        // For now, it's a one-shot display at player's Y level\n    }\n    \n    private boolean handleAdminCommands(CommandSender sender, String[] args, String mainLabel) {\n        if (args.length < 2) {\n            sendAdminHelp(sender, mainLabel);\n            return true;\n        }\n        String adminSubCommand = args[1].toLowerCase();\n        // ... (admin commands implementation) ...\n        switch (adminSubCommand) {\n            case \"reload\":\n                plugin.reloadPluginConfig();\n                sender.sendMessage(plugin.getMessage(\"admin.config-reloaded\"));\n                return true;\n            case \"forceabandon\": // /acd admin forceabandon <playerName>\n                if (args.length < 3) {\n                    sender.sendMessage(ChatColor.RED + \"Usage: /\" + mainLabel + \" admin forceabandon <playerName>\");\n                    return true;\n                }\n                OfflinePlayer targetOwner = Bukkit.getOfflinePlayer(args[2]);\n                if (!targetOwner.hasPlayedBefore() && !targetOwner.isOnline()){\n                    sender.sendMessage(plugin.getMessage(\"command.error.player-not-found\").replace(\"{player_name}\", args[2]));\n                    return true;\n                }\n                if (claimManager.abandonAllClaims(targetOwner.getUniqueId())) {\n                    sender.sendMessage(ChatColor.GREEN + \"Abandoned all claims for \" + targetOwner.getName());\n                } else {\n                    sender.sendMessage(ChatColor.RED + \"No claims found for \" + targetOwner.getName() + \" or failed to abandon.\");\n                }\n                return true;\n            // Add more admin commands: inspect, forceclaim, etc.\n            default:\n                sendAdminHelp(sender, mainLabel);\n                return true;\n        }\n    }\n\n    private void sendAdminHelp(CommandSender sender, String label) {\n        sender.sendMessage(ChatColor.RED + \"--- AutoClaim Defender Admin Help ---\");\n        sender.sendMessage(ChatColor.GOLD + \"/\" + label + \" admin reload\" + ChatColor.GRAY + \" - Reloads the plugin configuration.\");\n        sender.sendMessage(ChatColor.GOLD + \"/\" + label + \" admin forceabandon <player>\" + ChatColor.GRAY + \" - Abandons all claims of a player.\");\n        // Add more admin help lines\n    }\n\n    @Override\n    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        List<String> completions = new ArrayList<>();\n        List<String> subCommands = Arrays.asList(\"claim\", \"abandon\", \"trust\", \"untrust\", \"list\", \"showborder\", \"help\");\n        List<String> adminSubCommands = Arrays.asList(\"reload\", \"forceabandon\");\n\n        if (args.length == 1) {\n            for (String sc : subCommands) {\n                if (sc.startsWith(args[0].toLowerCase())) {\n                    completions.add(sc);\n                }\n            }\n            if (sender.hasPermission(\"autoclaimdefender.admin\") && \"admin\".startsWith(args[0].toLowerCase())) {\n                completions.add(\"admin\");\n            }\n        } else if (args.length == 2) {\n            if (args[0].equalsIgnoreCase(\"trust\") || args[0].equalsIgnoreCase(\"untrust\")) {\n                if (sender instanceof Player) {\n                    Player p = (Player) sender;\n                    Claim currentClaim = claimManager.getClaimAt(p.getLocation());\n                    if(args[0].equalsIgnoreCase(\"untrust\") && currentClaim != null && currentClaim.getOwnerUUID().equals(p.getUniqueId())){\n                         currentClaim.getTrustedPlayers().stream()\n                            .map(Bukkit::getOfflinePlayer)\n                            .filter(Objects::nonNull)\n                            .map(OfflinePlayer::getName)\n                            .filter(name -> name != null && name.toLowerCase().startsWith(args[1].toLowerCase()))\n                            .forEach(completions::add);\n                    } else {\n                         Bukkit.getOnlinePlayers().stream()\n                            .map(Player::getName)\n                            .filter(name -> name.toLowerCase().startsWith(args[1].toLowerCase()))\n                            .forEach(completions::add);\n                    }\n                }\n            } else if (args[0].equalsIgnoreCase(\"admin\") && sender.hasPermission(\"autoclaimdefender.admin\")) {\n                 for (String asc : adminSubCommands) {\n                    if (asc.startsWith(args[1].toLowerCase())) {\n                        completions.add(asc);\n                    }\n                }\n            }\n        } else if (args.length == 3 && args[0].equalsIgnoreCase(\"admin\") && args[1].equalsIgnoreCase(\"forceabandon\")) {\n            Bukkit.getOnlinePlayers().stream()\n                .map(Player::getName)\n                .filter(name -> name.toLowerCase().startsWith(args[2].toLowerCase()))\n                .forEach(completions::add);\n             // Could also suggest offline players if a list is maintained or from claim data\n        }\n        \n        Collections.sort(completions);\n        return completions;\n    }\n}\n"
    },
    {
      "path": "src/main/java/com/autoclaimdefender/listeners/ProtectionListener.java",
      "content": "package com.autoclaimdefender.listeners;\n\nimport com.autoclaimdefender.AutoClaimDefender;\nimport com.autoclaimdefender.Claim;\nimport com.autoclaimdefender.ClaimManager;\nimport org.bukkit.Location;\nimport org.bukkit.Material;\nimport org.bukkit.block.Block;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.entity.Player;\nimport org.bukkit.entity.Projectile;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.EventPriority;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.block.*;\nimport org.bukkit.event.entity.EntityDamageByEntityEvent;\nimport org.bukkit.event.entity.EntityExplodeEvent;\nimport org.bukkit.event.player.PlayerBucketEmptyEvent;\nimport org.bukkit.event.player.PlayerInteractEvent;\n\npublic class ProtectionListener implements Listener {\n    private final AutoClaimDefender plugin;\n    private final ClaimManager claimManager;\n\n    public ProtectionListener(AutoClaimDefender plugin) {\n        this.plugin = plugin;\n        this.claimManager = plugin.getClaimManager();\n    }\n\n    private boolean canPlayerBypass(Player player, Claim claim) {\n        if (player == null) return false; // Non-player action, typically protected\n        if (claim == null) return true; // No claim, no protection by this plugin\n        return claim.isTrusted(player) || player.hasPermission(\"autoclaimdefender.bypass.protection\");\n    }\n\n    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)\n    public void onBlockBreak(BlockBreakEvent event) {\n        Claim claim = claimManager.getClaimAt(event.getBlock().getLocation());\n        if (claim != null && !canPlayerBypass(event.getPlayer(), claim)) {\n            event.setCancelled(true);\n            event.getPlayer().sendMessage(plugin.getMessage(\"protection.error.cannot-break\"));\n        }\n    }\n\n    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)\n    public void onBlockPlace(BlockPlaceEvent event) {\n        Claim claim = claimManager.getClaimAt(event.getBlock().getLocation());\n        if (claim != null && !canPlayerBypass(event.getPlayer(), claim)) {\n            event.setCancelled(true);\n            event.getPlayer().sendMessage(plugin.getMessage(\"protection.error.cannot-build\"));\n        }\n    }\n\n    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)\n    public void onPlayerInteract(PlayerInteractEvent event) {\n        if (event.getAction() == Action.RIGHT_CLICK_BLOCK) {\n            Block clickedBlock = event.getClickedBlock();\n            if (clickedBlock != null) {\n                Material type = clickedBlock.getType();\n                // Protect containers, doors, gates, levers, buttons etc.\n                if (type.toString().contains(\"CHEST\") || type.toString().contains(\"DOOR\") || \n                    type.toString().contains(\"GATE\") || type.toString().contains(\"BUTTON\") || \n                    type.toString().contains(\"LEVER\") || type == Material.FURNACE || \n                    type == Material.BREWING_STAND || type == Material.DISPENSER || \n                    type == Material.DROPPER || type == Material.HOPPER || type == Material.BEACON) {\n                    \n                    Claim claim = claimManager.getClaimAt(clickedBlock.getLocation());\n                    if (claim != null && !canPlayerBypass(event.getPlayer(), claim)) {\n                        event.setCancelled(true);\n                        event.getPlayer().sendMessage(plugin.getMessage(\"protection.error.cannot-interact\"));\n                    }\n                }\n            }\n        }\n    }\n\n    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)\n    public void onEntityExplode(EntityExplodeEvent event) {\n        if (!plugin.getConfig().getBoolean(\"protections.tnt.enabled\", true)) return;\n\n        // Check if the explosion source is in a claim or if affected blocks are in a claim\n        Claim sourceClaim = claimManager.getClaimAt(event.getLocation());\n        if (sourceClaim != null) {\n            // TNT in a claim should not damage that claim or others, unless admin bypass for source?\n            // For now, simply prevent explosion damage within any claim from any source if protection is on.\n        }\n\n        event.blockList().removeIf(block -> {\n            Claim claim = claimManager.getClaimAt(block.getLocation());\n            // If block is in any claim, protect it.\n            // This prevents TNT placed outside from damaging a claim, and TNT inside from damaging its own claim.\n            return claim != null;\n        });\n    }\n\n    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)\n    public void onPlayerBucketEmpty(PlayerBucketEmptyEvent event) {\n        Material bucket = event.getBucket();\n        if (bucket == Material.LAVA_BUCKET && !plugin.getConfig().getBoolean(\"protections.lava.enabled\", true)) return;\n        // Could add water bucket protection too if desired\n\n        Location loc = event.getBlockClicked().getRelative(event.getBlockFace()).getLocation();\n        Claim claim = claimManager.getClaimAt(loc);\n        if (claim != null && !canPlayerBypass(event.getPlayer(), claim)) {\n            event.setCancelled(true);\n            event.getPlayer().sendMessage(plugin.getMessage(bucket == Material.LAVA_BUCKET ? \"protection.error.no-lava\" : \"protection.error.cannot-place-liquid\"));\n        }\n    }\n\n    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)\n    public void onBlockPistonExtend(BlockPistonExtendEvent event) {\n        if (!plugin.getConfig().getBoolean(\"protections.pistons.enabled\", true)) return;\n        Claim pistonClaim = claimManager.getClaimAt(event.getBlock().getLocation());\n        // If piston itself is in a claim, it implies owner action or trusted.\n        // We care more about blocks being pushed INTO another claim or OUT OF a claim.\n\n        for (Block block : event.getBlocks()) {\n            Location newLoc = block.getLocation().add(event.getDirection().getModX(), event.getDirection().getModY(), event.getDirection().getModZ());\n            Claim targetClaim = claimManager.getClaimAt(newLoc);\n            Claim sourceClaim = claimManager.getClaimAt(block.getLocation());\n\n            if (targetClaim != null && (pistonClaim == null || !targetClaim.equals(pistonClaim))) {\n                // Pushing into a different claim or an unclaimed piston pushing into a claim\n                event.setCancelled(true);\n                return;\n            }\n            if (sourceClaim != null && targetClaim == null) {\n                 // Pushing out of a claim into unclaimed territory, usually allowed but can be configured\n            }\n        }\n    }\n\n    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)\n    public void onBlockPistonRetract(BlockPistonRetractEvent event) {\n        if (!plugin.getConfig().getBoolean(\"protections.pistons.enabled\", true)) return;\n        // Similar logic to extend, check blocks being pulled\n        Claim pistonClaim = claimManager.getClaimAt(event.getBlock().getLocation());\n\n        for (Block block : event.getBlocks()) {\n            Claim blockClaim = claimManager.getClaimAt(block.getLocation());\n            if (blockClaim != null && (pistonClaim == null || !blockClaim.equals(pistonClaim))) {\n                // Piston in unclaimed land pulling from claim, or piston in one claim pulling from another.\n                event.setCancelled(true);\n                return;\n            }\n        }\n    }\n    \n    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)\n    public void onEntityDamageByEntity(EntityDamageByEntityEvent event) {\n        if (!(event.getEntity() instanceof Player)) return; // Only care about Player vs Player for now\n        \n        Player victim = (Player) event.getEntity();\n        Claim victimClaim = claimManager.getClaimAt(victim.getLocation());\n        \n        if (victimClaim == null) return; // Victim not in a claim\n        \n        Player attacker = null;\n        if (event.getDamager() instanceof Player) {\n            attacker = (Player) event.getDamager();\n        } else if (event.getDamager() instanceof Projectile) {\n            Projectile projectile = (Projectile) event.getDamager();\n            if (projectile.getShooter() instanceof Player) {\n                attacker = (Player) projectile.getShooter();\n            }\n        }\n        \n        if (attacker == null) return; // Attacker not a player\n        \n        // If PvP is disabled in config for claims (e.g. \"protections.pvp.enabled: false\")\n        if (!plugin.getConfig().getBoolean(\"protections.pvp.in-claims\", true)) {\n             if (!victimClaim.isTrusted(attacker)) { // Or more simply, if attacker is not owner/trusted of victim's claim location\n                 event.setCancelled(true);\n                 attacker.sendMessage(plugin.getMessage(\"protection.error.pvp-disabled-in-claim\"));\n             }\n        }\n    }\n}\n"
    }
  ],
  "deletedFiles": [],
  "modifiedFiles": [
    {
      "path": "pom.xml",
      "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.autoclaimdefender</groupId>\n    <artifactId>autoclaimdefender</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>AutoClaimDefender</name>\n    <description>A simple and safe Minecraft protection plugin that automatically claims land.</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.8.1</version>\n                <configuration>\n                    <source>${java.version}</source>\n                    <target>${java.version}</target>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.2.4</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <createDependencyReducedPom>false</createDependencyReducedPom>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n        <resources>\n            <resource>\n                <directory>src/main/resources</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n    </build>\n\n    <repositories>\n        <repository>\n            <id>spigotmc-repo</id>\n            <url>https://hub.spigotmc.org/nexus/content/repositories/snapshots/</url>\n        </repository>\n        <repository>\n            <id>sonatype</id>\n            <url>https://oss.sonatype.org/content/groups/public/</url>\n        </repository>\n        <!-- If using Vault, add its repository -->\n        <!-- \n        <repository>\n            <id>jitpack.io</id>\n            <url>https://jitpack.io</url>\n        </repository>\n        -->\n    </repositories>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.spigotmc</groupId>\n            <artifactId>spigot-api</artifactId>\n            <version>1.16.5-R0.1-SNAPSHOT</version> <!-- Or your target server version -->\n            <scope>provided</scope>\n        </dependency>\n        <!-- If using Vault for economy -->\n        <!-- \n        <dependency>\n            <groupId>com.github.MilkBowl</groupId>\n            <artifactId>VaultAPI</artifactId>\n            <version>1.7</version>\n            <scope>provided</scope>\n        </dependency>\n        -->\n    </dependencies>\n</project>\n"
    },
    {
      "path": "src/resources/config.yml",
      "content": "# AutoClaim Defender Configuration\n\n# Settings for automatic claiming on first placement of specified blocks\nauto-claim:\n  enabled: true\n  # Blocks that trigger the first auto-claim (uses Material names from Spigot API)\n  trigger-blocks:\n    - \"CHEST\"\n    - \"TRAPPED_CHEST\"\n    - \"FURNACE\"\n    - \"BLAST_FURNACE\"\n    - \"SMOKER\"\n    - \"CRAFTING_TABLE\"\n  # Radius of chunks to claim around the trigger block's chunk.\n  # 0 = 1x1 (just the chunk the block is in)\n  # 1 = 3x3 chunks centered on the trigger block's chunk\n  # 2 = 5x5 chunks, etc.\n  radius-chunks: 0\n  # Message sent to player on successful auto-claim\n  success-message: \"&aYou've automatically claimed this area! Type /acd help for commands.\"\n\n# Manual claiming settings\nclaims:\n  # Maximum number of claims a player can have (auto-claim counts towards this)\n  # Players with 'autoclaimdefender.bypass.claimlimit' permission ignore this.\n  max-claims-per-player: 5\n  # Default size for manual /claim (currently only supports the chunk player is in - 1x1)\n  # Future: could allow /claim <size> e.g. /claim 3x3\n  # default-manual-claim-radius-chunks: 0\n\n# Visual borders for claims\nvisual-borders:\n  enabled: true\n  # Particle type to use for borders (see Spigot API for Particle enum names)\n  # Examples: REDSTONE, FLAME, VILLAGER_HAPPY, CRIT_MAGIC\n  particle-type: \"REDSTONE\"\n  # Duration particles are shown for with /acd showborder (in seconds) - Not implemented yet, shows once\n  # display-duration-seconds: 10 \n\n# Protections within claims\nprotections:\n  # Prevent TNT explosions from damaging blocks within claims\n  tnt:\n    enabled: true\n  # Prevent unauthorized players from placing/using lava buckets in claims\n  lava:\n    enabled: true\n  # Prevent unauthorized piston movement from affecting blocks in/out of claims\n  pistons:\n    enabled: true\n  # Prevent PvP in claims between non-trusted members. If false, PvP is allowed subject to server rules.\n  pvp-in-claims: true\n  # More protections can be added here (e.g., specific mob griefing, fire spread)\n\n# Optional economy integration (requires Vault and an economy plugin)\n# This is a placeholder; full economy integration requires Vault API usage in code.\neconomy:\n  enabled: false\n  # Number of claims a player can make for free (including auto-claim)\n  free-claims: 1\n  # Cost for each additional claim beyond the free limit\n  cost-per-additional-claim: 1000.0\n\n# Messages (Can be customized here)\n# Placeholders: {player_name}, {max_claims}, {count}, {chunk_x}, {chunk_z}, {world}\nmessages:\n  prefix: \"&6[AutoClaimDefender] &r\"\n  command:\n    error:\n      no-permission: \"&cYou don't have permission to use this command.\"\n      player-only: \"&cThis command can only be used by a player.\"\n      player-not-found: \"&cPlayer '{player_name}' not found.\"\n      player-not-found-or-not-trusted: \"&cPlayer '{player_name}' not found or is not trusted in this claim.\"\n    usage:\n      trust: \"&eUsage: /acd trust <player_name>\"\n      untrust: \"&eUsage: /acd untrust <player_name>\"\n  claim:\n    success:\n      auto: \"&aYou've automatically claimed this area! ({radius}x{radius} chunks). Type /acd help for commands.\"\n      manual: \"&aChunk claimed successfully!\"\n    error:\n      overlap: \"&cThis area (or part of it) is already claimed.\"\n      max-claims-reached: \"&cYou have reached the maximum of {max_claims} claims.\"\n      not-in-own-claim: \"&cYou are not standing in a claim you own.\"\n      not-in-claim: \"&cYou are not standing in any claim.\"\n      abandon-failed: \"&cFailed to abandon the claim.\"\n      already-autoclaimed: \"&eYou have already received your first automatic claim.\"\n      invalid-block-for-autoclaim: \"&eThis block type does not trigger an auto-claim.\"\n    success:\n      abandoned: \"&aClaim successfully abandoned.\"\n    list:\n      header: \"&6Your Claims ({count}):\"\n      none: \"&eYou don't have any claims yet.\"\n  trust:\n    success: \"&aPlayer {player_name} is now trusted in this claim.\"\n    error:\n      self: \"&cYou cannot trust yourself.\"\n  untrust:\n    success: \"&aPlayer {player_name} is no longer trusted in this claim.\"\n    error:\n      not-trusted: \"&cPlayer {player_name} was not trusted in this claim.\"\n  protection:\n    error:\n      cannot-build: \"&cYou cannot build here, this area is claimed.\"\n      cannot-break: \"&cYou cannot break blocks here, this area is claimed.\"\n      cannot-interact: \"&cYou cannot interact with that here, this area is claimed.\"\n      no-tnt: \"&cTNT is disabled in claimed areas.\"\n      no-lava: \"&cLava placement is restricted in claimed areas.\"\n      no-pistons: \"&cPistons are restricted in claimed areas.\"\n      cannot-place-liquid: \"&cYou cannot place that liquid here, this area is claimed.\"\n      pvp-disabled-in-claim: \"&cPvP is disabled in this claim against non-trusted members.\"\n  borders:\n    disabled: \"&cVisual borders are disabled in the config.\"\n    showing: \"&aShowing claim border particles...\"\n  admin:\n    config-reloaded: \"&aConfiguration reloaded.\"\n"
    },
    {
      "path": "src/resources/plugin.yml",
      "content": "name: AutoClaimDefender\nversion: ${project.version} # This will be replaced by Maven\nmain: com.autoclaimdefender.AutoClaimDefender\napi-version: 1.13 # Minimum Spigot API version your plugin supports (e.g., 1.13, 1.16)\nauthor: YourName\ndescription: A simple and safe Minecraft protection plugin that automatically claims land.\nwebsite: https://example.com\n\ncommands:\n  autoclaimdefender:\n    description: Main command for AutoClaimDefender.\n    aliases: [acd, claimdefender]\n    usage: /<command> [help|claim|abandon|trust|untrust|list|showborder|admin]\n    permission: autoclaimdefender.use\n\npermissions:\n  autoclaimdefender.use:\n    description: Allows basic use of AutoClaimDefender commands.\n    default: true\n  autoclaimdefender.claim:\n    description: Allows manual claiming of land.\n    default: true\n  autoclaimdefender.abandon:\n    description: Allows abandoning of own claims.\n    default: true\n  autoclaimdefender.trust:\n    description: Allows trusting players in own claims.\n    default: true\n  autoclaimdefender.untrust:\n    description: Allows untrusting players from own claims.\n    default: true\n  autoclaimdefender.list:\n    description: Allows listing of own claims.\n    default: true\n  autoclaimdefender.showborder:\n    description: Allows viewing claim borders.\n    default: true\n  autoclaimdefender.autoclaim:\n    description: Allows player to receive an automatic first claim.\n    default: true\n  autoclaimdefender.bypass.protection:\n    description: Allows bypassing claim protections (e.g., build, break in any claim).\n    default: op\n  autoclaimdefender.bypass.claimlimit:\n    description: Allows bypassing the maximum claim limit.\n    default: op\n  autoclaimdefender.admin:\n    description: Allows use of admin commands for AutoClaimDefender.\n    default: op\n"
    }
  ],
  "renamedFiles": [
    {
      "oldPath": "src/main/java/com/pegasus/mybasicplugin/MyBasicPlugin.java",
      "newPath": "src/main/java/com/autoclaimdefender/AutoClaimDefender.java"
    },
    {
      "oldPath": "src/main/java/com/pegasus/mybasicplugin/listeners/PlayerJoinListener.java",
      "newPath": "src/main/java/com/autoclaimdefender/listeners/AutoClaimListener.java"
    }
  ],
  "unchangedFiles": [],
  "modifiedFilesContent": {
    "src/main/java/com/autoclaimdefender/AutoClaimDefender.java": "package com.autoclaimdefender;\n\nimport com.autoclaimdefender.commands.CoreCommand;\nimport com.autoclaimdefender.listeners.AutoClaimListener;\nimport com.autoclaimdefender.listeners.ProtectionListener;\nimport org.bukkit.ChatColor;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.configuration.serialization.ConfigurationSerialization;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport java.util.Objects;\n\npublic class AutoClaimDefender extends JavaPlugin {\n\n    private ClaimManager claimManager;\n    private FileConfiguration messagesConfig;\n\n    @Override\n    public void onEnable() {\n        // Register Claim class for serialization\n        ConfigurationSerialization.registerClass(Claim.class, \"AutoClaimDefender.Claim\");\n\n        // Load configurations\n        saveDefaultConfig(); // Saves config.yml if not exists\n        reloadPluginConfig(); // Loads config and messages\n\n        // Initialize managers\n        this.claimManager = new ClaimManager(this);\n\n        // Register commands\n        CoreCommand coreCommand = new CoreCommand(this);\n        Objects.requireNonNull(this.getCommand(\"autoclaimdefender\")).setExecutor(coreCommand);\n        Objects.requireNonNull(this.getCommand(\"autoclaimdefender\")).setTabCompleter(coreCommand);\n\n        // Register listeners\n        getServer().getPluginManager().registerEvents(new AutoClaimListener(this), this);\n        getServer().getPluginManager().registerEvents(new ProtectionListener(this), this);\n\n        getLogger().info(\"AutoClaim Defender has been enabled!\");\n    }\n\n    @Override\n    public void onDisable() {\n        if (claimManager != null) {\n            claimManager.saveClaims();\n        }\n        getLogger().info(\"AutoClaim Defender has been disabled.\");\n    }\n\n    public ClaimManager getClaimManager() {\n        return claimManager;\n    }\n\n    public void reloadPluginConfig() {\n        reloadConfig(); // Reloads config.yml\n        // If messages were in a separate file, load it here.\n        // For now, messages are part of config.yml or hardcoded with placeholders.\n    }\n    \n    public String getMessage(String path) {\n        String rawMessage = getConfig().getString(\"messages.\" + path, \"&cMessage not found: \" + path);\n        String prefix = getConfig().getString(\"messages.prefix\", \"&6[ACD] &r\");\n        return ChatColor.translateAlternateColorCodes('&', prefix + rawMessage);\n    }\n\n    public String getRawMessage(String path) {\n        String rawMessage = getConfig().getString(\"messages.\" + path, \"&cMessage not found: \" + path);\n        return ChatColor.translateAlternateColorCodes('&', rawMessage);\n    }\n}\n",
    "src/main/java/com/autoclaimdefender/listeners/AutoClaimListener.java": "package com.autoclaimdefender.listeners;\n\nimport com.autoclaimdefender.AutoClaimDefender;\nimport com.autoclaimdefender.Claim;\nimport com.autoclaimdefender.ClaimManager;\nimport org.bukkit.Chunk;\nimport org.bukkit.Material;\nimport org.bukkit.block.Block;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.EventPriority;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.block.BlockPlaceEvent;\n\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class AutoClaimListener implements Listener {\n    private final AutoClaimDefender plugin;\n    private final ClaimManager claimManager;\n    private final List<String> triggerBlockStrings;\n    private final Set<Material> triggerBlockMaterials = new HashSet<>();\n\n    public AutoClaimListener(AutoClaimDefender plugin) {\n        this.plugin = plugin;\n        this.claimManager = plugin.getClaimManager();\n        this.triggerBlockStrings = plugin.getConfig().getStringList(\"auto-claim.trigger-blocks\");\n        for (String matName : triggerBlockStrings) {\n            try {\n                triggerBlockMaterials.add(Material.valueOf(matName.toUpperCase()));\n            } catch (IllegalArgumentException e) {\n                plugin.getLogger().warning(\"Invalid trigger block material in config: \" + matName);\n            }\n        }\n    }\n\n    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n    public void onFirstBlockPlace(BlockPlaceEvent event) {\n        if (!plugin.getConfig().getBoolean(\"auto-claim.enabled\", true)) {\n            return;\n        }\n\n        Player player = event.getPlayer();\n        if (!player.hasPermission(\"autoclaimdefender.autoclaim\")) {\n            return;\n        }\n\n        if (claimManager.hasPlayerAutoClaimed(player)) {\n            return; // Player has already received their auto-claim\n        }\n\n        Block placedBlock = event.getBlockPlaced();\n        if (!triggerBlockMaterials.contains(placedBlock.getType())) {\n            return; // Not a designated trigger block\n        }\n        \n        // Check if player already owns any claim (maybe they manually claimed first)\n        if (!claimManager.getPlayerClaims(player.getUniqueId()).isEmpty()) {\n            // If they already have claims, mark as auto-claimed to prevent future triggers but don't give a new one.\n            // Or, allow auto-claim if they have 0 claims only. Current logic assumes auto-claim is the very first claim.\n            claimManager.markPlayerAsAutoClaimed(player);\n            return;\n        }\n\n        int radius = plugin.getConfig().getInt(\"auto-claim.radius-chunks\", 0);\n        Set<Chunk> chunksToClaim = new HashSet<>();\n        Chunk centerChunk = placedBlock.getChunk();\n\n        for (int xOffset = -radius; xOffset <= radius; xOffset++) {\n            for (int zOffset = -radius; zOffset <= radius; zOffset++) {\n                chunksToClaim.add(centerChunk.getWorld().getChunkAt(centerChunk.getX() + xOffset, centerChunk.getZ() + zOffset));\n            }\n        }\n\n        // Check for overlaps BEFORE creating the claim\n        for (Chunk chunk : chunksToClaim) {\n            if (claimManager.getClaimAt(chunk) != null) {\n                player.sendMessage(plugin.getMessage(\"claim.error.overlap\"));\n                // Don't mark as auto-claimed yet, they can try placing elsewhere\n                return;\n            }\n        }\n\n        Claim newClaim = claimManager.createClaim(player, chunksToClaim);\n        if (newClaim != null) {\n            claimManager.markPlayerAsAutoClaimed(player);\n            String successMsg = plugin.getConfig().getString(\"auto-claim.success-message\", \"&aYou've automatically claimed this area! Type /acd help for commands.\");\n            successMsg = successMsg.replace(\"{radius}\", String.valueOf(radius * 2 + 1)); // e.g. radius 0 = 1x1, radius 1 = 3x3\n            player.sendMessage(plugin.getRawMessage(\"messages.prefix\") + org.bukkit.ChatColor.translateAlternateColorCodes('&', successMsg));\n        } else {\n            // Error message likely sent by claimManager (e.g. overlap, though checked above)\n            // Or could be another issue if createClaim can fail for other reasons.\n        }\n    }\n}\n"
  }
}
```
--------------------------------------------------

File: pom.xml
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.autoclaimdefender</groupId>
    <artifactId>autoclaimdefender</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <name>AutoClaimDefender</name>
    <description>A simple and safe Minecraft protection plugin that automatically claims land.</description>

    <properties>
        <java.version>1.8</java.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.2.4</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <createDependencyReducedPom>false</createDependencyReducedPom>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>

    <repositories>
        <repository>
            <id>spigotmc-repo</id>
            <url>https://hub.spigotmc.org/nexus/content/repositories/snapshots/</url>
        </repository>
        <repository>
            <id>sonatype</id>
            <url>https://oss.sonatype.org/content/groups/public/</url>
        </repository>
        <!-- If using Vault, add its repository -->
        <!-- 
        <repository>
            <id>jitpack.io</id>
            <url>https://jitpack.io</url>
        </repository>
        -->
    </repositories>

    <dependencies>
        <dependency>
            <groupId>org.spigotmc</groupId>
            <artifactId>spigot-api</artifactId>
            <version>1.16.5-R0.1-SNAPSHOT</version> <!-- Or your target server version -->
            <scope>provided</scope>
        </dependency>
        <!-- If using Vault for economy -->
        <!-- 
        <dependency>
            <groupId>com.github.MilkBowl</groupId>
            <artifactId>VaultAPI</artifactId>
            <version>1.7</version>
            <scope>provided</scope>
        </dependency>
        -->
    </dependencies>
</project>

--------------------------------------------------

File: run.py
--------------------------------------------------
import os
import tkinter as tk
from tkinter import filedialog

def select_folder():
    root = tk.Tk()
    root.withdraw()  # Hide the main window
    folder_selected = filedialog.askdirectory(title="Select a Folder")
    return folder_selected

def compile_files_to_txt(output_file="compiled_output.txt"):
    folder_path = select_folder()
    
    if not folder_path:
        print("No folder selected. Exiting...")
        return
    
    with open(output_file, "w", encoding="utf-8") as txt_file:
        for root, dirs, files in os.walk(folder_path):
            txt_file.write(f"Folder: {root}\n")
            txt_file.write("=" * 50 + "\n")
            
            for file_name in files:
                file_path = os.path.join(root, file_name)
                txt_file.write(f"File: {file_name}\n")
                txt_file.write("-" * 50 + "\n")
                
                try:
                    with open(file_path, "r", encoding="utf-8") as file:
                        txt_file.write(file.read())
                except Exception as e:
                    txt_file.write(f"[Error reading file: {e}]\n")
                
                txt_file.write("\n" + "-" * 50 + "\n\n")
    
    print(f"Compilation complete! Output saved to: {output_file}")

# Run the function
compile_files_to_txt()
--------------------------------------------------

Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\src
==================================================
Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\src\main
==================================================
Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\src\main\java
==================================================
Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\src\main\java\com
==================================================
Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\src\main\java\com\autoclaimdefender
==================================================
File: AutoClaimDefender.java
--------------------------------------------------
package com.pegasus.mybasicplugin;

import com.pegasus.mybasicplugin.listeners.PlayerJoinListener; 
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.ChatColor;

public class MyBasicPlugin extends JavaPlugin {

    private static MyBasicPlugin instance;

    @Override
    public void onEnable() {
        instance = this;

        saveDefaultConfig();

        String welcomeMessage = getConfig().getString("welcome-message", "Welcome, %player%!");
        boolean enableWelcome = getConfig().getBoolean("enable-welcome-message", true);

        getServer().getPluginManager().registerEvents(new PlayerJoinListener(this), this);

        getLogger().info(ChatColor.GREEN + getName() + " version " + getDescription().getVersion() + " has been enabled!");
        getLogger().info("Welcome message enabled: " + enableWelcome + ", Message: " + welcomeMessage);
    }

    @Override
    public void onDisable() {
        getLogger().info(ChatColor.RED + getName() + " has been disabled!");
        instance = null;
    }

    public static MyBasicPlugin getInstance() {
        return instance;
    }
}
--------------------------------------------------

File: Claim.java
--------------------------------------------------
package com.autoclaimdefender;

import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.configuration.serialization.ConfigurationSerializable;
import org.bukkit.entity.Player;

import java.util.*;
import java.util.stream.Collectors;

public class Claim implements ConfigurationSerializable {
    private UUID ownerUUID;
    private String ownerName; // For easier identification, not for primary key
    private String worldName;
    private Set<Long> chunkKeys; // Packed chunk coords (x << 32 | z)
    private Set<UUID> trustedPlayers;
    private Date creationDate;

    public Claim(UUID ownerUUID, String ownerName, World world, Set<Chunk> chunks) {
        this.ownerUUID = ownerUUID;
        this.ownerName = ownerName;
        this.worldName = world.getName();
        this.chunkKeys = new HashSet<>();
        for (Chunk chunk : chunks) {
            this.chunkKeys.add(packChunkCoords(chunk.getX(), chunk.getZ()));
        }
        this.trustedPlayers = new HashSet<>();
        this.creationDate = new Date();
    }

    // Deserialization constructor
    @SuppressWarnings("unchecked")
    public Claim(Map<String, Object> map) {
        this.ownerUUID = UUID.fromString((String) map.get("ownerUUID"));
        this.ownerName = (String) map.get("ownerName");
        this.worldName = (String) map.get("worldName");
        this.chunkKeys = ((List<Long>) map.get("chunkKeys")).stream().collect(Collectors.toSet());
        this.trustedPlayers = ((List<String>) map.get("trustedPlayers")).stream()
                .map(UUID::fromString)
                .collect(Collectors.toSet());
        this.creationDate = (Date) map.get("creationDate");
    }

    @Override
    public Map<String, Object> serialize() {
        Map<String, Object> map = new HashMap<>();
        map.put("ownerUUID", ownerUUID.toString());
        map.put("ownerName", ownerName);
        map.put("worldName", worldName);
        map.put("chunkKeys", new ArrayList<>(chunkKeys));
        map.put("trustedPlayers", trustedPlayers.stream().map(UUID::toString).collect(Collectors.toList()));
        map.put("creationDate", creationDate);
        return map;
    }

    public static long packChunkCoords(int x, int z) {
        return (long) x << 32 | (long) z & 0xFFFFFFFFL;
    }

    public static int unpackChunkX(long key) {
        return (int) (key >> 32);
    }

    public static int unpackChunkZ(long key) {
        return (int) (key & 0xFFFFFFFFL);
    }

    public UUID getOwnerUUID() {
        return ownerUUID;
    }

    public String getOwnerName() {
        return ownerName;
    }

    public String getWorldName() {
        return worldName;
    }

    public Set<Long> getChunkKeys() {
        return Collections.unmodifiableSet(chunkKeys);
    }

    public boolean isChunkInClaim(Chunk chunk) {
        return chunk.getWorld().getName().equals(worldName) && chunkKeys.contains(packChunkCoords(chunk.getX(), chunk.getZ()));
    }

    public boolean isLocationInClaim(Location location) {
        return isChunkInClaim(location.getChunk());
    }

    public boolean isTrusted(Player player) {
        return isTrusted(player.getUniqueId());
    }

    public boolean isTrusted(UUID playerUUID) {
        return trustedPlayers.contains(playerUUID) || playerUUID.equals(ownerUUID);
    }

    public void trustPlayer(UUID playerUUID) {
        trustedPlayers.add(playerUUID);
    }

    public void untrustPlayer(UUID playerUUID) {
        trustedPlayers.remove(playerUUID);
    }

    public Set<UUID> getTrustedPlayers() {
        return Collections.unmodifiableSet(trustedPlayers);
    }
    
    public Date getCreationDate() {
        return creationDate;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Claim claim = (Claim) o;
        return ownerUUID.equals(claim.ownerUUID) && worldName.equals(claim.worldName) && chunkKeys.equals(claim.chunkKeys);
    }

    @Override
    public int hashCode() {
        return Objects.hash(ownerUUID, worldName, chunkKeys);
    }
}

--------------------------------------------------

File: ClaimManager.java
--------------------------------------------------
package com.autoclaimdefender;

import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.OfflinePlayer;
import org.bukkit.World;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

public class ClaimManager {
    private final AutoClaimDefender plugin;
    private final Map<UUID, List<Claim>> playerClaims = new ConcurrentHashMap<>(); // Owner UUID to their claims
    private final Set<UUID> autoClaimedPlayers = ConcurrentHashMap.newKeySet(); // Players who have used their first auto-claim
    private File dataFile;

    public ClaimManager(AutoClaimDefender plugin) {
        this.plugin = plugin;
        this.dataFile = new File(plugin.getDataFolder(), "claims_data.yml");
        loadClaims();
    }

    public Claim createClaim(Player owner, Set<Chunk> chunksToClaim) {
        if (chunksToClaim.isEmpty()) {
            return null;
        }
        // Check for overlaps with existing claims
        for (Chunk chunk : chunksToClaim) {
            if (getClaimAt(chunk) != null) {
                owner.sendMessage(plugin.getMessage("claim.error.overlap"));
                return null;
            }
        }

        Claim claim = new Claim(owner.getUniqueId(), owner.getName(), chunksToClaim.iterator().next().getWorld(), chunksToClaim);
        playerClaims.computeIfAbsent(owner.getUniqueId(), k -> new ArrayList<>()).add(claim);
        saveClaims();
        return claim;
    }

    public boolean abandonClaim(Claim claim) {
        if (claim == null) return false;
        List<Claim> claims = playerClaims.get(claim.getOwnerUUID());
        if (claims != null) {
            boolean removed = claims.remove(claim);
            if (claims.isEmpty()) {
                playerClaims.remove(claim.getOwnerUUID());
            }
            if (removed) {
                saveClaims();
            }
            return removed;
        }
        return false;
    }
    
    public boolean abandonAllClaims(UUID ownerUUID) {
        if (playerClaims.containsKey(ownerUUID)) {
            playerClaims.remove(ownerUUID);
            saveClaims();
            return true;
        }
        return false;
    }

    public Claim getClaimAt(Location location) {
        return getClaimAt(location.getChunk());
    }

    public Claim getClaimAt(Chunk chunk) {
        long chunkKey = Claim.packChunkCoords(chunk.getX(), chunk.getZ());
        String worldName = chunk.getWorld().getName();
        for (List<Claim> claims : playerClaims.values()) {
            for (Claim claim : claims) {
                if (claim.getWorldName().equals(worldName) && claim.getChunkKeys().contains(chunkKey)) {
                    return claim;
                }
            }
        }
        return null;
    }

    public List<Claim> getPlayerClaims(UUID playerUUID) {
        return playerClaims.getOrDefault(playerUUID, Collections.emptyList());
    }

    public int getPlayerClaimCount(UUID playerUUID) {
        return getPlayerClaims(playerUUID).size();
    }

    public void markPlayerAsAutoClaimed(Player player) {
        autoClaimedPlayers.add(player.getUniqueId());
        saveClaims(); // Save this status as well
    }

    public boolean hasPlayerAutoClaimed(Player player) {
        return autoClaimedPlayers.contains(player.getUniqueId());
    }

    public void trustPlayerInClaim(Claim claim, OfflinePlayer trustedPlayer) {
        claim.trustPlayer(trustedPlayer.getUniqueId());
        saveClaims();
    }

    public void untrustPlayerInClaim(Claim claim, OfflinePlayer untrustedPlayer) {
        claim.untrustPlayer(untrustedPlayer.getUniqueId());
        saveClaims();
    }

    @SuppressWarnings("unchecked")
    public void loadClaims() {
        if (!dataFile.exists()) {
            return;
        }
        FileConfiguration dataConfig = YamlConfiguration.loadConfiguration(dataFile);
        List<Map<?, ?>> claimsList = dataConfig.getMapList("claims");
        for (Map<?, ?> claimMap : claimsList) {
            Claim claim = new Claim((Map<String, Object>) claimMap);
            playerClaims.computeIfAbsent(claim.getOwnerUUID(), k -> new ArrayList<>()).add(claim);
        }

        List<String> autoClaimedUUIDs = dataConfig.getStringList("autoClaimedPlayers");
        for (String uuidStr : autoClaimedUUIDs) {
            try {
                autoClaimedPlayers.add(UUID.fromString(uuidStr));
            } catch (IllegalArgumentException e) {
                plugin.getLogger().warning("Failed to load auto-claimed player UUID: " + uuidStr);
            }
        }
    }

    public void saveClaims() {
        FileConfiguration dataConfig = new YamlConfiguration();
        List<Map<String, Object>> claimsToSave = new ArrayList<>();
        for (List<Claim> claims : playerClaims.values()) {
            for (Claim claim : claims) {
                claimsToSave.add(claim.serialize());
            }
        }
        dataConfig.set("claims", claimsToSave);
        dataConfig.set("autoClaimedPlayers", autoClaimedPlayers.stream().map(UUID::toString).collect(Collectors.toList()));

        try {
            dataConfig.save(dataFile);
        } catch (IOException e) {
            plugin.getLogger().severe("Could not save claims data to " + dataFile.getName());
            e.printStackTrace();
        }
    }
}

--------------------------------------------------

Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\src\main\java\com\autoclaimdefender\commands
==================================================
File: CoreCommand.java
--------------------------------------------------
package com.autoclaimdefender.commands;

import com.autoclaimdefender.AutoClaimDefender;
import com.autoclaimdefender.Claim;
import com.autoclaimdefender.ClaimManager;
import org.bukkit.*;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.command.TabCompleter;
import org.bukkit.entity.Player;
import org.bukkit.scheduler.BukkitRunnable;

import java.util.*;
import java.util.stream.Collectors;

public class CoreCommand implements CommandExecutor, TabCompleter {
    private final AutoClaimDefender plugin;
    private final ClaimManager claimManager;

    public CoreCommand(AutoClaimDefender plugin) {
        this.plugin = plugin;
        this.claimManager = plugin.getClaimManager();
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (args.length == 0 || args[0].equalsIgnoreCase("help")) {
            sendHelpMessage(sender, label);
            return true;
        }

        String subCommand = args[0].toLowerCase();

        if (!(sender instanceof Player) && needsPlayer(subCommand)) {
            sender.sendMessage(plugin.getMessage("command.error.player-only"));
            return true;
        }

        Player player = (sender instanceof Player) ? (Player) sender : null;

        switch (subCommand) {
            case "claim":
                return handleClaim(player, args);
            case "abandon":
            case "abandonclaim":
                return handleAbandonClaim(player, args);
            case "trust":
                return handleTrust(player, args);
            case "untrust":
                return handleUntrust(player, args);
            case "list":
            case "claims":
                return handleListClaims(player, args);
            case "border":
            case "showborder":
                return handleShowBorder(player);
            case "admin":
                 if (!sender.hasPermission("autoclaimdefender.admin")) {
                    sender.sendMessage(plugin.getMessage("command.error.no-permission"));
                    return true;
                }
                return handleAdminCommands(sender, args, label);
            default:
                sendHelpMessage(sender, label);
                return true;
        }
    }

    private boolean needsPlayer(String subCommand) {
        return Arrays.asList("claim", "abandon", "abandonclaim", "trust", "untrust", "list", "claims", "border", "showborder").contains(subCommand);
    }

    private void sendHelpMessage(CommandSender sender, String label) {
        sender.sendMessage(ChatColor.GOLD + "--- AutoClaim Defender Help ---");
        sender.sendMessage(ChatColor.YELLOW + "/" + label + " claim" + ChatColor.GRAY + " - Claims the chunk you are standing in.");
        sender.sendMessage(ChatColor.YELLOW + "/" + label + " abandon" + ChatColor.GRAY + " - Abandons the claim you are in.");
        sender.sendMessage(ChatColor.YELLOW + "/" + label + " trust <player>" + ChatColor.GRAY + " - Trusts a player in your claim.");
        sender.sendMessage(ChatColor.YELLOW + "/" + label + " untrust <player>" + ChatColor.GRAY + " - Untrusts a player from your claim.");
        sender.sendMessage(ChatColor.YELLOW + "/" + label + " list" + ChatColor.GRAY + " - Lists your claims.");
        sender.sendMessage(ChatColor.YELLOW + "/" + label + " showborder" + ChatColor.GRAY + " - Shows the border of the current claim.");
        if (sender.hasPermission("autoclaimdefender.admin")) {
            sender.sendMessage(ChatColor.RED + "/" + label + " admin <subcommand>" + ChatColor.GRAY + " - Admin commands.");
        }
    }

    private boolean handleClaim(Player player, String[] args) {
        if (!player.hasPermission("autoclaimdefender.claim")) {
            player.sendMessage(plugin.getMessage("command.error.no-permission"));
            return true;
        }

        int maxClaims = plugin.getConfig().getInt("claims.max-claims-per-player", 5);
        if (claimManager.getPlayerClaimCount(player.getUniqueId()) >= maxClaims && !player.hasPermission("autoclaimdefender.bypass.claimlimit")) {
            player.sendMessage(plugin.getMessage("claim.error.max-claims-reached").replace("{max_claims}", String.valueOf(maxClaims)));
            return true;
        }

        // Economy check (placeholder)
        if (plugin.getConfig().getBoolean("economy.enabled") && claimManager.getPlayerClaimCount(player.getUniqueId()) >= plugin.getConfig().getInt("economy.free-claims")) {
            double cost = plugin.getConfig().getDouble("economy.cost-per-additional-claim");
            // TODO: Implement Vault economy check and charge. For now, just a message.
            player.sendMessage(ChatColor.YELLOW + "Claiming this chunk would cost " + cost + " (Economy not fully implemented yet).");
        }

        Set<Chunk> chunksToClaim = new HashSet<>();
        chunksToClaim.add(player.getLocation().getChunk());
        // Potentially expand to a configurable radius if args specify, e.g. /claim 3x3

        Claim claim = claimManager.createClaim(player, chunksToClaim);
        if (claim != null) {
            player.sendMessage(plugin.getMessage("claim.success.manual"));
        } else {
            // Error message already sent by ClaimManager (e.g., overlap)
        }
        return true;
    }

    private boolean handleAbandonClaim(Player player, String[] args) {
        if (!player.hasPermission("autoclaimdefender.abandon")) {
            player.sendMessage(plugin.getMessage("command.error.no-permission"));
            return true;
        }

        Claim claim = claimManager.getClaimAt(player.getLocation());
        if (claim == null || !claim.getOwnerUUID().equals(player.getUniqueId())) {
            player.sendMessage(plugin.getMessage("claim.error.not-in-own-claim"));
            return true;
        }

        if (claimManager.abandonClaim(claim)) {
            player.sendMessage(plugin.getMessage("claim.success.abandoned"));
        } else {
            player.sendMessage(plugin.getMessage("claim.error.abandon-failed"));
        }
        return true;
    }

    private boolean handleTrust(Player player, String[] args) {
        if (!player.hasPermission("autoclaimdefender.trust")) {
            player.sendMessage(plugin.getMessage("command.error.no-permission"));
            return true;
        }
        if (args.length < 2) {
            player.sendMessage(plugin.getMessage("command.usage.trust"));
            return true;
        }

        Claim claim = claimManager.getClaimAt(player.getLocation());
        if (claim == null || !claim.getOwnerUUID().equals(player.getUniqueId())) {
            player.sendMessage(plugin.getMessage("claim.error.not-in-own-claim"));
            return true;
        }

        OfflinePlayer target = Bukkit.getOfflinePlayer(args[1]);
        if (!target.hasPlayedBefore() && !target.isOnline()) {
            player.sendMessage(plugin.getMessage("command.error.player-not-found").replace("{player_name}", args[1]));
            return true;
        }
        if (target.getUniqueId().equals(player.getUniqueId())){
            player.sendMessage(plugin.getMessage("trust.error.self"));
            return true;
        }

        claimManager.trustPlayerInClaim(claim, target);
        player.sendMessage(plugin.getMessage("trust.success").replace("{player_name}", target.getName()));
        return true;
    }

    private boolean handleUntrust(Player player, String[] args) {
        if (!player.hasPermission("autoclaimdefender.untrust")) {
            player.sendMessage(plugin.getMessage("command.error.no-permission"));
            return true;
        }
        if (args.length < 2) {
            player.sendMessage(plugin.getMessage("command.usage.untrust"));
            return true;
        }

        Claim claim = claimManager.getClaimAt(player.getLocation());
        if (claim == null || !claim.getOwnerUUID().equals(player.getUniqueId())) {
            player.sendMessage(plugin.getMessage("claim.error.not-in-own-claim"));
            return true;
        }

        OfflinePlayer target = Bukkit.getOfflinePlayer(args[1]);
         if (!target.hasPlayedBefore() && !target.isOnline()) { // Check if player is known
            // Try to find by UUID if name changed, or check from claim's trusted list
            UUID targetUUID = null;
            for(UUID trustedId : claim.getTrustedPlayers()){
                OfflinePlayer p = Bukkit.getOfflinePlayer(trustedId);
                if(p.getName() != null && p.getName().equalsIgnoreCase(args[1])){
                    targetUUID = trustedId;
                    target = p;
                    break;
                }
            }
            if(targetUUID == null){
                player.sendMessage(plugin.getMessage("command.error.player-not-found-or-not-trusted").replace("{player_name}", args[1]));
                return true;
            }
        }

        if (!claim.getTrustedPlayers().contains(target.getUniqueId())){
            player.sendMessage(plugin.getMessage("untrust.error.not-trusted").replace("{player_name}", target.getName()));
            return true;
        }

        claimManager.untrustPlayerInClaim(claim, target);
        player.sendMessage(plugin.getMessage("untrust.success").replace("{player_name}", target.getName()));
        return true;
    }

    private boolean handleListClaims(Player player, String[] args) {
        if (!player.hasPermission("autoclaimdefender.list")) {
            player.sendMessage(plugin.getMessage("command.error.no-permission"));
            return true;
        }

        List<Claim> claims = claimManager.getPlayerClaims(player.getUniqueId());
        if (claims.isEmpty()) {
            player.sendMessage(plugin.getMessage("claim.list.none"));
            return true;
        }

        player.sendMessage(plugin.getMessage("claim.list.header").replace("{count}", String.valueOf(claims.size())));
        for (int i = 0; i < claims.size(); i++) {
            Claim claim = claims.get(i);
            long firstChunkKey = claim.getChunkKeys().iterator().next();
            int chunkX = Claim.unpackChunkX(firstChunkKey);
            int chunkZ = Claim.unpackChunkZ(firstChunkKey);
            player.sendMessage(ChatColor.YELLOW + " " + (i + 1) + ". " + ChatColor.GRAY + "World: " + claim.getWorldName() + ", Chunks: " + claim.getChunkKeys().size() + " (e.g., at X: " + chunkX + ", Z: " + chunkZ + ")");
        }
        return true;
    }

    private boolean handleShowBorder(Player player) {
        if (!plugin.getConfig().getBoolean("visual-borders.enabled")) {
            player.sendMessage(plugin.getMessage("borders.disabled"));
            return true;
        }
        if (!player.hasPermission("autoclaimdefender.showborder")) {
            player.sendMessage(plugin.getMessage("command.error.no-permission"));
            return true;
        }

        Claim claim = claimManager.getClaimAt(player.getLocation());
        if (claim == null) {
            player.sendMessage(plugin.getMessage("claim.error.not-in-claim"));
            return true;
        }

        player.sendMessage(plugin.getMessage("borders.showing"));
        showClaimBorders(player, claim);
        return true;
    }

    private void showClaimBorders(Player player, Claim claim) {
        World world = Bukkit.getWorld(claim.getWorldName());
        if (world == null) return;

        Particle particleType;
        try {
            particleType = Particle.valueOf(plugin.getConfig().getString("visual-borders.particle-type", "REDSTONE").toUpperCase());
        } catch (IllegalArgumentException e) {
            particleType = Particle.REDSTONE;
            plugin.getLogger().warning("Invalid particle type in config.yml, defaulting to REDSTONE.");
        }
        final Particle finalParticleType = particleType;
        
        new BukkitRunnable() {
            @Override
            public void run() {
                for (long chunkKey : claim.getChunkKeys()) {
                    int chunkX = Claim.unpackChunkX(chunkKey);
                    int chunkZ = Claim.unpackChunkZ(chunkKey);
                    Chunk chunk = world.getChunkAt(chunkX, chunkZ);

                    for (int i = 0; i < 16; i++) {
                        // Top and bottom edges (X direction)
                        world.spawnParticle(finalParticleType, chunk.getBlock(i, player.getLocation().getBlockY(), 0).getLocation().add(0.5, 0.5, 0.5), 1, 0, 0, 0, 0);
                        world.spawnParticle(finalParticleType, chunk.getBlock(i, player.getLocation().getBlockY(), 15).getLocation().add(0.5, 0.5, 0.5), 1, 0, 0, 0, 0);
                        // Left and right edges (Z direction)
                        world.spawnParticle(finalParticleType, chunk.getBlock(0, player.getLocation().getBlockY(), i).getLocation().add(0.5, 0.5, 0.5), 1, 0, 0, 0, 0);
                        world.spawnParticle(finalParticleType, chunk.getBlock(15, player.getLocation().getBlockY(), i).getLocation().add(0.5, 0.5, 0.5), 1, 0, 0, 0, 0);
                    }
                }
            }
        }.runTaskLater(plugin, 0L); // Show immediately
        
        // Could add a task to remove them or show for a limited time
        // For now, it's a one-shot display at player's Y level
    }
    
    private boolean handleAdminCommands(CommandSender sender, String[] args, String mainLabel) {
        if (args.length < 2) {
            sendAdminHelp(sender, mainLabel);
            return true;
        }
        String adminSubCommand = args[1].toLowerCase();
        // ... (admin commands implementation) ...
        switch (adminSubCommand) {
            case "reload":
                plugin.reloadPluginConfig();
                sender.sendMessage(plugin.getMessage("admin.config-reloaded"));
                return true;
            case "forceabandon": // /acd admin forceabandon <playerName>
                if (args.length < 3) {
                    sender.sendMessage(ChatColor.RED + "Usage: /" + mainLabel + " admin forceabandon <playerName>");
                    return true;
                }
                OfflinePlayer targetOwner = Bukkit.getOfflinePlayer(args[2]);
                if (!targetOwner.hasPlayedBefore() && !targetOwner.isOnline()){
                    sender.sendMessage(plugin.getMessage("command.error.player-not-found").replace("{player_name}", args[2]));
                    return true;
                }
                if (claimManager.abandonAllClaims(targetOwner.getUniqueId())) {
                    sender.sendMessage(ChatColor.GREEN + "Abandoned all claims for " + targetOwner.getName());
                } else {
                    sender.sendMessage(ChatColor.RED + "No claims found for " + targetOwner.getName() + " or failed to abandon.");
                }
                return true;
            // Add more admin commands: inspect, forceclaim, etc.
            default:
                sendAdminHelp(sender, mainLabel);
                return true;
        }
    }

    private void sendAdminHelp(CommandSender sender, String label) {
        sender.sendMessage(ChatColor.RED + "--- AutoClaim Defender Admin Help ---");
        sender.sendMessage(ChatColor.GOLD + "/" + label + " admin reload" + ChatColor.GRAY + " - Reloads the plugin configuration.");
        sender.sendMessage(ChatColor.GOLD + "/" + label + " admin forceabandon <player>" + ChatColor.GRAY + " - Abandons all claims of a player.");
        // Add more admin help lines
    }

    @Override
    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
        List<String> completions = new ArrayList<>();
        List<String> subCommands = Arrays.asList("claim", "abandon", "trust", "untrust", "list", "showborder", "help");
        List<String> adminSubCommands = Arrays.asList("reload", "forceabandon");

        if (args.length == 1) {
            for (String sc : subCommands) {
                if (sc.startsWith(args[0].toLowerCase())) {
                    completions.add(sc);
                }
            }
            if (sender.hasPermission("autoclaimdefender.admin") && "admin".startsWith(args[0].toLowerCase())) {
                completions.add("admin");
            }
        } else if (args.length == 2) {
            if (args[0].equalsIgnoreCase("trust") || args[0].equalsIgnoreCase("untrust")) {
                if (sender instanceof Player) {
                    Player p = (Player) sender;
                    Claim currentClaim = claimManager.getClaimAt(p.getLocation());
                    if(args[0].equalsIgnoreCase("untrust") && currentClaim != null && currentClaim.getOwnerUUID().equals(p.getUniqueId())){
                         currentClaim.getTrustedPlayers().stream()
                            .map(Bukkit::getOfflinePlayer)
                            .filter(Objects::nonNull)
                            .map(OfflinePlayer::getName)
                            .filter(name -> name != null && name.toLowerCase().startsWith(args[1].toLowerCase()))
                            .forEach(completions::add);
                    } else {
                         Bukkit.getOnlinePlayers().stream()
                            .map(Player::getName)
                            .filter(name -> name.toLowerCase().startsWith(args[1].toLowerCase()))
                            .forEach(completions::add);
                    }
                }
            } else if (args[0].equalsIgnoreCase("admin") && sender.hasPermission("autoclaimdefender.admin")) {
                 for (String asc : adminSubCommands) {
                    if (asc.startsWith(args[1].toLowerCase())) {
                        completions.add(asc);
                    }
                }
            }
        } else if (args.length == 3 && args[0].equalsIgnoreCase("admin") && args[1].equalsIgnoreCase("forceabandon")) {
            Bukkit.getOnlinePlayers().stream()
                .map(Player::getName)
                .filter(name -> name.toLowerCase().startsWith(args[2].toLowerCase()))
                .forEach(completions::add);
             // Could also suggest offline players if a list is maintained or from claim data
        }
        
        Collections.sort(completions);
        return completions;
    }
}

--------------------------------------------------

Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\src\main\java\com\autoclaimdefender\listeners
==================================================
File: AutoClaimListener.java
--------------------------------------------------
package com.pegasus.mybasicplugin.listeners;

import com.pegasus.mybasicplugin.MyBasicPlugin; 
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;

public class PlayerJoinListener implements Listener {

    private final MyBasicPlugin plugin;

    public PlayerJoinListener(MyBasicPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onPlayerJoin(PlayerJoinEvent event) {
        Player player = event.getPlayer();

        if (plugin.getConfig().getBoolean("enable-welcome-message", true)) {
            String welcomeMessageFormat = plugin.getConfig().getString("welcome-message", "Welcome to the server, %player%!");
            String personalizedMessage = welcomeMessageFormat.replace("%player%", player.getName());

            player.sendMessage(ChatColor.translateAlternateColorCodes('&', personalizedMessage));
            plugin.getLogger().info(player.getName() + " joined. Sent welcome message.");
        } else {
            plugin.getLogger().info(player.getName() + " joined. Welcome message is disabled.");
        }
    }
}
--------------------------------------------------

File: ProtectionListener.java
--------------------------------------------------
package com.autoclaimdefender.listeners;

import com.autoclaimdefender.AutoClaimDefender;
import com.autoclaimdefender.Claim;
import com.autoclaimdefender.ClaimManager;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.entity.Projectile;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.*;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.entity.EntityExplodeEvent;
import org.bukkit.event.player.PlayerBucketEmptyEvent;
import org.bukkit.event.player.PlayerInteractEvent;

public class ProtectionListener implements Listener {
    private final AutoClaimDefender plugin;
    private final ClaimManager claimManager;

    public ProtectionListener(AutoClaimDefender plugin) {
        this.plugin = plugin;
        this.claimManager = plugin.getClaimManager();
    }

    private boolean canPlayerBypass(Player player, Claim claim) {
        if (player == null) return false; // Non-player action, typically protected
        if (claim == null) return true; // No claim, no protection by this plugin
        return claim.isTrusted(player) || player.hasPermission("autoclaimdefender.bypass.protection");
    }

    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    public void onBlockBreak(BlockBreakEvent event) {
        Claim claim = claimManager.getClaimAt(event.getBlock().getLocation());
        if (claim != null && !canPlayerBypass(event.getPlayer(), claim)) {
            event.setCancelled(true);
            event.getPlayer().sendMessage(plugin.getMessage("protection.error.cannot-break"));
        }
    }

    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    public void onBlockPlace(BlockPlaceEvent event) {
        Claim claim = claimManager.getClaimAt(event.getBlock().getLocation());
        if (claim != null && !canPlayerBypass(event.getPlayer(), claim)) {
            event.setCancelled(true);
            event.getPlayer().sendMessage(plugin.getMessage("protection.error.cannot-build"));
        }
    }

    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    public void onPlayerInteract(PlayerInteractEvent event) {
        if (event.getAction() == Action.RIGHT_CLICK_BLOCK) {
            Block clickedBlock = event.getClickedBlock();
            if (clickedBlock != null) {
                Material type = clickedBlock.getType();
                // Protect containers, doors, gates, levers, buttons etc.
                if (type.toString().contains("CHEST") || type.toString().contains("DOOR") || 
                    type.toString().contains("GATE") || type.toString().contains("BUTTON") || 
                    type.toString().contains("LEVER") || type == Material.FURNACE || 
                    type == Material.BREWING_STAND || type == Material.DISPENSER || 
                    type == Material.DROPPER || type == Material.HOPPER || type == Material.BEACON) {
                    
                    Claim claim = claimManager.getClaimAt(clickedBlock.getLocation());
                    if (claim != null && !canPlayerBypass(event.getPlayer(), claim)) {
                        event.setCancelled(true);
                        event.getPlayer().sendMessage(plugin.getMessage("protection.error.cannot-interact"));
                    }
                }
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    public void onEntityExplode(EntityExplodeEvent event) {
        if (!plugin.getConfig().getBoolean("protections.tnt.enabled", true)) return;

        // Check if the explosion source is in a claim or if affected blocks are in a claim
        Claim sourceClaim = claimManager.getClaimAt(event.getLocation());
        if (sourceClaim != null) {
            // TNT in a claim should not damage that claim or others, unless admin bypass for source?
            // For now, simply prevent explosion damage within any claim from any source if protection is on.
        }

        event.blockList().removeIf(block -> {
            Claim claim = claimManager.getClaimAt(block.getLocation());
            // If block is in any claim, protect it.
            // This prevents TNT placed outside from damaging a claim, and TNT inside from damaging its own claim.
            return claim != null;
        });
    }

    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    public void onPlayerBucketEmpty(PlayerBucketEmptyEvent event) {
        Material bucket = event.getBucket();
        if (bucket == Material.LAVA_BUCKET && !plugin.getConfig().getBoolean("protections.lava.enabled", true)) return;
        // Could add water bucket protection too if desired

        Location loc = event.getBlockClicked().getRelative(event.getBlockFace()).getLocation();
        Claim claim = claimManager.getClaimAt(loc);
        if (claim != null && !canPlayerBypass(event.getPlayer(), claim)) {
            event.setCancelled(true);
            event.getPlayer().sendMessage(plugin.getMessage(bucket == Material.LAVA_BUCKET ? "protection.error.no-lava" : "protection.error.cannot-place-liquid"));
        }
    }

    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    public void onBlockPistonExtend(BlockPistonExtendEvent event) {
        if (!plugin.getConfig().getBoolean("protections.pistons.enabled", true)) return;
        Claim pistonClaim = claimManager.getClaimAt(event.getBlock().getLocation());
        // If piston itself is in a claim, it implies owner action or trusted.
        // We care more about blocks being pushed INTO another claim or OUT OF a claim.

        for (Block block : event.getBlocks()) {
            Location newLoc = block.getLocation().add(event.getDirection().getModX(), event.getDirection().getModY(), event.getDirection().getModZ());
            Claim targetClaim = claimManager.getClaimAt(newLoc);
            Claim sourceClaim = claimManager.getClaimAt(block.getLocation());

            if (targetClaim != null && (pistonClaim == null || !targetClaim.equals(pistonClaim))) {
                // Pushing into a different claim or an unclaimed piston pushing into a claim
                event.setCancelled(true);
                return;
            }
            if (sourceClaim != null && targetClaim == null) {
                 // Pushing out of a claim into unclaimed territory, usually allowed but can be configured
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    public void onBlockPistonRetract(BlockPistonRetractEvent event) {
        if (!plugin.getConfig().getBoolean("protections.pistons.enabled", true)) return;
        // Similar logic to extend, check blocks being pulled
        Claim pistonClaim = claimManager.getClaimAt(event.getBlock().getLocation());

        for (Block block : event.getBlocks()) {
            Claim blockClaim = claimManager.getClaimAt(block.getLocation());
            if (blockClaim != null && (pistonClaim == null || !blockClaim.equals(pistonClaim))) {
                // Piston in unclaimed land pulling from claim, or piston in one claim pulling from another.
                event.setCancelled(true);
                return;
            }
        }
    }
    
    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    public void onEntityDamageByEntity(EntityDamageByEntityEvent event) {
        if (!(event.getEntity() instanceof Player)) return; // Only care about Player vs Player for now
        
        Player victim = (Player) event.getEntity();
        Claim victimClaim = claimManager.getClaimAt(victim.getLocation());
        
        if (victimClaim == null) return; // Victim not in a claim
        
        Player attacker = null;
        if (event.getDamager() instanceof Player) {
            attacker = (Player) event.getDamager();
        } else if (event.getDamager() instanceof Projectile) {
            Projectile projectile = (Projectile) event.getDamager();
            if (projectile.getShooter() instanceof Player) {
                attacker = (Player) projectile.getShooter();
            }
        }
        
        if (attacker == null) return; // Attacker not a player
        
        // If PvP is disabled in config for claims (e.g. "protections.pvp.enabled: false")
        if (!plugin.getConfig().getBoolean("protections.pvp.in-claims", true)) {
             if (!victimClaim.isTrusted(attacker)) { // Or more simply, if attacker is not owner/trusted of victim's claim location
                 event.setCancelled(true);
                 attacker.sendMessage(plugin.getMessage("protection.error.pvp-disabled-in-claim"));
             }
        }
    }
}

--------------------------------------------------

Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\src\main\java\com\pegasus
==================================================
Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\src\main\java\com\pegasus\mybasicplugin
==================================================
Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\src\main\java\com\pegasus\mybasicplugin\listeners
==================================================
Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\src\main\resources
==================================================
File: config.yml
--------------------------------------------------
# AutoClaim Defender Configuration

# Settings for automatic claiming on first placement of specified blocks
auto-claim:
  enabled: true
  # Blocks that trigger the first auto-claim (uses Material names from Spigot API)
  trigger-blocks:
    - "CHEST"
    - "TRAPPED_CHEST"
    - "FURNACE"
    - "BLAST_FURNACE"
    - "SMOKER"
    - "CRAFTING_TABLE"
  # Radius of chunks to claim around the trigger block's chunk.
  # 0 = 1x1 (just the chunk the block is in)
  # 1 = 3x3 chunks centered on the trigger block's chunk
  # 2 = 5x5 chunks, etc.
  radius-chunks: 0
  # Message sent to player on successful auto-claim
  success-message: "&aYou've automatically claimed this area! Type /acd help for commands."

# Manual claiming settings
claims:
  # Maximum number of claims a player can have (auto-claim counts towards this)
  # Players with 'autoclaimdefender.bypass.claimlimit' permission ignore this.
  max-claims-per-player: 5
  # Default size for manual /claim (currently only supports the chunk player is in - 1x1)
  # Future: could allow /claim <size> e.g. /claim 3x3
  # default-manual-claim-radius-chunks: 0

# Visual borders for claims
visual-borders:
  enabled: true
  # Particle type to use for borders (see Spigot API for Particle enum names)
  # Examples: REDSTONE, FLAME, VILLAGER_HAPPY, CRIT_MAGIC
  particle-type: "REDSTONE"
  # Duration particles are shown for with /acd showborder (in seconds) - Not implemented yet, shows once
  # display-duration-seconds: 10 

# Protections within claims
protections:
  # Prevent TNT explosions from damaging blocks within claims
  tnt:
    enabled: true
  # Prevent unauthorized players from placing/using lava buckets in claims
  lava:
    enabled: true
  # Prevent unauthorized piston movement from affecting blocks in/out of claims
  pistons:
    enabled: true
  # Prevent PvP in claims between non-trusted members. If false, PvP is allowed subject to server rules.
  pvp-in-claims: true
  # More protections can be added here (e.g., specific mob griefing, fire spread)

# Optional economy integration (requires Vault and an economy plugin)
# This is a placeholder; full economy integration requires Vault API usage in code.
economy:
  enabled: false
  # Number of claims a player can make for free (including auto-claim)
  free-claims: 1
  # Cost for each additional claim beyond the free limit
  cost-per-additional-claim: 1000.0

# Messages (Can be customized here)
# Placeholders: {player_name}, {max_claims}, {count}, {chunk_x}, {chunk_z}, {world}
messages:
  prefix: "&6[AutoClaimDefender] &r"
  command:
    error:
      no-permission: "&cYou don't have permission to use this command."
      player-only: "&cThis command can only be used by a player."
      player-not-found: "&cPlayer '{player_name}' not found."
      player-not-found-or-not-trusted: "&cPlayer '{player_name}' not found or is not trusted in this claim."
    usage:
      trust: "&eUsage: /acd trust <player_name>"
      untrust: "&eUsage: /acd untrust <player_name>"
  claim:
    success:
      auto: "&aYou've automatically claimed this area! ({radius}x{radius} chunks). Type /acd help for commands."
      manual: "&aChunk claimed successfully!"
    error:
      overlap: "&cThis area (or part of it) is already claimed."
      max-claims-reached: "&cYou have reached the maximum of {max_claims} claims."
      not-in-own-claim: "&cYou are not standing in a claim you own."
      not-in-claim: "&cYou are not standing in any claim."
      abandon-failed: "&cFailed to abandon the claim."
      already-autoclaimed: "&eYou have already received your first automatic claim."
      invalid-block-for-autoclaim: "&eThis block type does not trigger an auto-claim."
    success:
      abandoned: "&aClaim successfully abandoned."
    list:
      header: "&6Your Claims ({count}):"
      none: "&eYou don't have any claims yet."
  trust:
    success: "&aPlayer {player_name} is now trusted in this claim."
    error:
      self: "&cYou cannot trust yourself."
  untrust:
    success: "&aPlayer {player_name} is no longer trusted in this claim."
    error:
      not-trusted: "&cPlayer {player_name} was not trusted in this claim."
  protection:
    error:
      cannot-build: "&cYou cannot build here, this area is claimed."
      cannot-break: "&cYou cannot break blocks here, this area is claimed."
      cannot-interact: "&cYou cannot interact with that here, this area is claimed."
      no-tnt: "&cTNT is disabled in claimed areas."
      no-lava: "&cLava placement is restricted in claimed areas."
      no-pistons: "&cPistons are restricted in claimed areas."
      cannot-place-liquid: "&cYou cannot place that liquid here, this area is claimed."
      pvp-disabled-in-claim: "&cPvP is disabled in this claim against non-trusted members."
  borders:
    disabled: "&cVisual borders are disabled in the config."
    showing: "&aShowing claim border particles..."
  admin:
    config-reloaded: "&aConfiguration reloaded."

--------------------------------------------------

File: plugin.yml
--------------------------------------------------
name: AutoClaimDefender
version: ${project.version} # This will be replaced by Maven
main: com.autoclaimdefender.AutoClaimDefender
api-version: 1.13 # Minimum Spigot API version your plugin supports (e.g., 1.13, 1.16)
author: YourName
description: A simple and safe Minecraft protection plugin that automatically claims land.
website: https://example.com

commands:
  autoclaimdefender:
    description: Main command for AutoClaimDefender.
    aliases: [acd, claimdefender]
    usage: /<command> [help|claim|abandon|trust|untrust|list|showborder|admin]
    permission: autoclaimdefender.use

permissions:
  autoclaimdefender.use:
    description: Allows basic use of AutoClaimDefender commands.
    default: true
  autoclaimdefender.claim:
    description: Allows manual claiming of land.
    default: true
  autoclaimdefender.abandon:
    description: Allows abandoning of own claims.
    default: true
  autoclaimdefender.trust:
    description: Allows trusting players in own claims.
    default: true
  autoclaimdefender.untrust:
    description: Allows untrusting players from own claims.
    default: true
  autoclaimdefender.list:
    description: Allows listing of own claims.
    default: true
  autoclaimdefender.showborder:
    description: Allows viewing claim borders.
    default: true
  autoclaimdefender.autoclaim:
    description: Allows player to receive an automatic first claim.
    default: true
  autoclaimdefender.bypass.protection:
    description: Allows bypassing claim protections (e.g., build, break in any claim).
    default: op
  autoclaimdefender.bypass.claimlimit:
    description: Allows bypassing the maximum claim limit.
    default: op
  autoclaimdefender.admin:
    description: Allows use of admin commands for AutoClaimDefender.
    default: op

--------------------------------------------------

Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\src\resources
==================================================
File: config.yml
--------------------------------------------------
# AutoClaim Defender Configuration

# Settings for automatic claiming on first placement of specified blocks
auto-claim:
  enabled: true
  # Blocks that trigger the first auto-claim (uses Material names from Spigot API)
  trigger-blocks:
    - "CHEST"
    - "TRAPPED_CHEST"
    - "FURNACE"
    - "BLAST_FURNACE"
    - "SMOKER"
    - "CRAFTING_TABLE"
  # Radius of chunks to claim around the trigger block's chunk.
  # 0 = 1x1 (just the chunk the block is in)
  # 1 = 3x3 chunks centered on the trigger block's chunk
  # 2 = 5x5 chunks, etc.
  radius-chunks: 0
  # Message sent to player on successful auto-claim
  success-message: "&aYou've automatically claimed this area! Type /acd help for commands."

# Manual claiming settings
claims:
  # Maximum number of claims a player can have (auto-claim counts towards this)
  # Players with 'autoclaimdefender.bypass.claimlimit' permission ignore this.
  max-claims-per-player: 5
  # Default size for manual /claim (currently only supports the chunk player is in - 1x1)
  # Future: could allow /claim <size> e.g. /claim 3x3
  # default-manual-claim-radius-chunks: 0

# Visual borders for claims
visual-borders:
  enabled: true
  # Particle type to use for borders (see Spigot API for Particle enum names)
  # Examples: REDSTONE, FLAME, VILLAGER_HAPPY, CRIT_MAGIC
  particle-type: "REDSTONE"
  # Duration particles are shown for with /acd showborder (in seconds) - Not implemented yet, shows once
  # display-duration-seconds: 10 

# Protections within claims
protections:
  # Prevent TNT explosions from damaging blocks within claims
  tnt:
    enabled: true
  # Prevent unauthorized players from placing/using lava buckets in claims
  lava:
    enabled: true
  # Prevent unauthorized piston movement from affecting blocks in/out of claims
  pistons:
    enabled: true
  # Prevent PvP in claims between non-trusted members. If false, PvP is allowed subject to server rules.
  pvp-in-claims: true
  # More protections can be added here (e.g., specific mob griefing, fire spread)

# Optional economy integration (requires Vault and an economy plugin)
# This is a placeholder; full economy integration requires Vault API usage in code.
economy:
  enabled: false
  # Number of claims a player can make for free (including auto-claim)
  free-claims: 1
  # Cost for each additional claim beyond the free limit
  cost-per-additional-claim: 1000.0

# Messages (Can be customized here)
# Placeholders: {player_name}, {max_claims}, {count}, {chunk_x}, {chunk_z}, {world}
messages:
  prefix: "&6[AutoClaimDefender] &r"
  command:
    error:
      no-permission: "&cYou don't have permission to use this command."
      player-only: "&cThis command can only be used by a player."
      player-not-found: "&cPlayer '{player_name}' not found."
      player-not-found-or-not-trusted: "&cPlayer '{player_name}' not found or is not trusted in this claim."
    usage:
      trust: "&eUsage: /acd trust <player_name>"
      untrust: "&eUsage: /acd untrust <player_name>"
  claim:
    success:
      auto: "&aYou've automatically claimed this area! ({radius}x{radius} chunks). Type /acd help for commands."
      manual: "&aChunk claimed successfully!"
    error:
      overlap: "&cThis area (or part of it) is already claimed."
      max-claims-reached: "&cYou have reached the maximum of {max_claims} claims."
      not-in-own-claim: "&cYou are not standing in a claim you own."
      not-in-claim: "&cYou are not standing in any claim."
      abandon-failed: "&cFailed to abandon the claim."
      already-autoclaimed: "&eYou have already received your first automatic claim."
      invalid-block-for-autoclaim: "&eThis block type does not trigger an auto-claim."
    success:
      abandoned: "&aClaim successfully abandoned."
    list:
      header: "&6Your Claims ({count}):"
      none: "&eYou don't have any claims yet."
  trust:
    success: "&aPlayer {player_name} is now trusted in this claim."
    error:
      self: "&cYou cannot trust yourself."
  untrust:
    success: "&aPlayer {player_name} is no longer trusted in this claim."
    error:
      not-trusted: "&cPlayer {player_name} was not trusted in this claim."
  protection:
    error:
      cannot-build: "&cYou cannot build here, this area is claimed."
      cannot-break: "&cYou cannot break blocks here, this area is claimed."
      cannot-interact: "&cYou cannot interact with that here, this area is claimed."
      no-tnt: "&cTNT is disabled in claimed areas."
      no-lava: "&cLava placement is restricted in claimed areas."
      no-pistons: "&cPistons are restricted in claimed areas."
      cannot-place-liquid: "&cYou cannot place that liquid here, this area is claimed."
      pvp-disabled-in-claim: "&cPvP is disabled in this claim against non-trusted members."
  borders:
    disabled: "&cVisual borders are disabled in the config."
    showing: "&aShowing claim border particles..."
  admin:
    config-reloaded: "&aConfiguration reloaded."

--------------------------------------------------

File: plugin.yml
--------------------------------------------------
name: AutoClaimDefender
version: ${project.version} # This will be replaced by Maven
main: com.autoclaimdefender.AutoClaimDefender
api-version: 1.13 # Minimum Spigot API version your plugin supports (e.g., 1.13, 1.16)
author: YourName
description: A simple and safe Minecraft protection plugin that automatically claims land.
website: https://example.com

commands:
  autoclaimdefender:
    description: Main command for AutoClaimDefender.
    aliases: [acd, claimdefender]
    usage: /<command> [help|claim|abandon|trust|untrust|list|showborder|admin]
    permission: autoclaimdefender.use

permissions:
  autoclaimdefender.use:
    description: Allows basic use of AutoClaimDefender commands.
    default: true
  autoclaimdefender.claim:
    description: Allows manual claiming of land.
    default: true
  autoclaimdefender.abandon:
    description: Allows abandoning of own claims.
    default: true
  autoclaimdefender.trust:
    description: Allows trusting players in own claims.
    default: true
  autoclaimdefender.untrust:
    description: Allows untrusting players from own claims.
    default: true
  autoclaimdefender.list:
    description: Allows listing of own claims.
    default: true
  autoclaimdefender.showborder:
    description: Allows viewing claim borders.
    default: true
  autoclaimdefender.autoclaim:
    description: Allows player to receive an automatic first claim.
    default: true
  autoclaimdefender.bypass.protection:
    description: Allows bypassing claim protections (e.g., build, break in any claim).
    default: op
  autoclaimdefender.bypass.claimlimit:
    description: Allows bypassing the maximum claim limit.
    default: op
  autoclaimdefender.admin:
    description: Allows use of admin commands for AutoClaimDefender.
    default: op

--------------------------------------------------

Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\target
==================================================
Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\target\classes
==================================================
File: config.yml
--------------------------------------------------
# AutoClaim Defender Configuration

# Settings for automatic claiming on first placement of specified blocks
auto-claim:
  enabled: true
  # Blocks that trigger the first auto-claim (uses Material names from Spigot API)
  trigger-blocks:
    - "CHEST"
    - "TRAPPED_CHEST"
    - "FURNACE"
    - "BLAST_FURNACE"
    - "SMOKER"
    - "CRAFTING_TABLE"
  # Radius of chunks to claim around the trigger block's chunk.
  # 0 = 1x1 (just the chunk the block is in)
  # 1 = 3x3 chunks centered on the trigger block's chunk
  # 2 = 5x5 chunks, etc.
  radius-chunks: 0
  # Message sent to player on successful auto-claim
  success-message: "&aYou've automatically claimed this area! Type /acd help for commands."

# Manual claiming settings
claims:
  # Maximum number of claims a player can have (auto-claim counts towards this)
  # Players with 'autoclaimdefender.bypass.claimlimit' permission ignore this.
  max-claims-per-player: 5
  # Default size for manual /claim (currently only supports the chunk player is in - 1x1)
  # Future: could allow /claim <size> e.g. /claim 3x3
  # default-manual-claim-radius-chunks: 0

# Visual borders for claims
visual-borders:
  enabled: true
  # Particle type to use for borders (see Spigot API for Particle enum names)
  # Examples: REDSTONE, FLAME, VILLAGER_HAPPY, CRIT_MAGIC
  particle-type: "REDSTONE"
  # Duration particles are shown for with /acd showborder (in seconds) - Not implemented yet, shows once
  # display-duration-seconds: 10 

# Protections within claims
protections:
  # Prevent TNT explosions from damaging blocks within claims
  tnt:
    enabled: true
  # Prevent unauthorized players from placing/using lava buckets in claims
  lava:
    enabled: true
  # Prevent unauthorized piston movement from affecting blocks in/out of claims
  pistons:
    enabled: true
  # Prevent PvP in claims between non-trusted members. If false, PvP is allowed subject to server rules.
  pvp-in-claims: true
  # More protections can be added here (e.g., specific mob griefing, fire spread)

# Optional economy integration (requires Vault and an economy plugin)
# This is a placeholder; full economy integration requires Vault API usage in code.
economy:
  enabled: false
  # Number of claims a player can make for free (including auto-claim)
  free-claims: 1
  # Cost for each additional claim beyond the free limit
  cost-per-additional-claim: 1000.0

# Messages (Can be customized here)
# Placeholders: {player_name}, {max_claims}, {count}, {chunk_x}, {chunk_z}, {world}
messages:
  prefix: "&6[AutoClaimDefender] &r"
  command:
    error:
      no-permission: "&cYou don't have permission to use this command."
      player-only: "&cThis command can only be used by a player."
      player-not-found: "&cPlayer '{player_name}' not found."
      player-not-found-or-not-trusted: "&cPlayer '{player_name}' not found or is not trusted in this claim."
    usage:
      trust: "&eUsage: /acd trust <player_name>"
      untrust: "&eUsage: /acd untrust <player_name>"
  claim:
    success:
      auto: "&aYou've automatically claimed this area! ({radius}x{radius} chunks). Type /acd help for commands."
      manual: "&aChunk claimed successfully!"
    error:
      overlap: "&cThis area (or part of it) is already claimed."
      max-claims-reached: "&cYou have reached the maximum of {max_claims} claims."
      not-in-own-claim: "&cYou are not standing in a claim you own."
      not-in-claim: "&cYou are not standing in any claim."
      abandon-failed: "&cFailed to abandon the claim."
      already-autoclaimed: "&eYou have already received your first automatic claim."
      invalid-block-for-autoclaim: "&eThis block type does not trigger an auto-claim."
    success:
      abandoned: "&aClaim successfully abandoned."
    list:
      header: "&6Your Claims ({count}):"
      none: "&eYou don't have any claims yet."
  trust:
    success: "&aPlayer {player_name} is now trusted in this claim."
    error:
      self: "&cYou cannot trust yourself."
  untrust:
    success: "&aPlayer {player_name} is no longer trusted in this claim."
    error:
      not-trusted: "&cPlayer {player_name} was not trusted in this claim."
  protection:
    error:
      cannot-build: "&cYou cannot build here, this area is claimed."
      cannot-break: "&cYou cannot break blocks here, this area is claimed."
      cannot-interact: "&cYou cannot interact with that here, this area is claimed."
      no-tnt: "&cTNT is disabled in claimed areas."
      no-lava: "&cLava placement is restricted in claimed areas."
      no-pistons: "&cPistons are restricted in claimed areas."
      cannot-place-liquid: "&cYou cannot place that liquid here, this area is claimed."
      pvp-disabled-in-claim: "&cPvP is disabled in this claim against non-trusted members."
  borders:
    disabled: "&cVisual borders are disabled in the config."
    showing: "&aShowing claim border particles..."
  admin:
    config-reloaded: "&aConfiguration reloaded."

--------------------------------------------------

File: plugin.yml
--------------------------------------------------
name: AutoClaimDefender
version: 1.0.0 # This will be replaced by Maven
main: com.autoclaimdefender.AutoClaimDefender
api-version: 1.13 # Minimum Spigot API version your plugin supports (e.g., 1.13, 1.16)
author: YourName
description: A simple and safe Minecraft protection plugin that automatically claims land.
website: https://example.com

commands:
  autoclaimdefender:
    description: Main command for AutoClaimDefender.
    aliases: [acd, claimdefender]
    usage: /<command> [help|claim|abandon|trust|untrust|list|showborder|admin]
    permission: autoclaimdefender.use

permissions:
  autoclaimdefender.use:
    description: Allows basic use of AutoClaimDefender commands.
    default: true
  autoclaimdefender.claim:
    description: Allows manual claiming of land.
    default: true
  autoclaimdefender.abandon:
    description: Allows abandoning of own claims.
    default: true
  autoclaimdefender.trust:
    description: Allows trusting players in own claims.
    default: true
  autoclaimdefender.untrust:
    description: Allows untrusting players from own claims.
    default: true
  autoclaimdefender.list:
    description: Allows listing of own claims.
    default: true
  autoclaimdefender.showborder:
    description: Allows viewing claim borders.
    default: true
  autoclaimdefender.autoclaim:
    description: Allows player to receive an automatic first claim.
    default: true
  autoclaimdefender.bypass.protection:
    description: Allows bypassing claim protections (e.g., build, break in any claim).
    default: op
  autoclaimdefender.bypass.claimlimit:
    description: Allows bypassing the maximum claim limit.
    default: op
  autoclaimdefender.admin:
    description: Allows use of admin commands for AutoClaimDefender.
    default: op

--------------------------------------------------

Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\target\generated-sources
==================================================
Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\target\generated-sources\annotations
==================================================
Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\target\maven-status
==================================================
Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\target\maven-status\maven-compiler-plugin
==================================================
Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\target\maven-status\maven-compiler-plugin\compile
==================================================
Folder: D:/Codespace/pegasus_api/generated/autoclaimdefender\target\maven-status\maven-compiler-plugin\compile\default-compile
==================================================
File: createdFiles.lst
--------------------------------------------------

--------------------------------------------------

File: inputFiles.lst
--------------------------------------------------
D:\Codespace\pegasus_api\generated\autoclaimdefender\src\main\java\com\autoclaimdefender\ClaimManager.java
D:\Codespace\pegasus_api\generated\autoclaimdefender\src\main\java\com\autoclaimdefender\commands\CoreCommand.java
D:\Codespace\pegasus_api\generated\autoclaimdefender\src\main\java\com\autoclaimdefender\Claim.java
D:\Codespace\pegasus_api\generated\autoclaimdefender\src\main\java\com\autoclaimdefender\listeners\AutoClaimListener.java
D:\Codespace\pegasus_api\generated\autoclaimdefender\src\main\java\com\autoclaimdefender\listeners\ProtectionListener.java
D:\Codespace\pegasus_api\generated\autoclaimdefender\src\main\java\com\autoclaimdefender\AutoClaimDefender.java

--------------------------------------------------

